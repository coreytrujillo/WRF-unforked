MODULE G_MODULE_DEP_SIMPLE
    USE module_dep_simple, only: kpart,rac,rclo,rcls,rgso,rgss,ri,rlu,ri_pan,     &
                                 c0_pan,k_pan,luse2usgs,dratio,hstar,hstar4,f0,   &
                                 dhr,scpr23,seasonal_pft,dep_seasons,nlu,         &
                                 small_value,large_value,isice_temp,iswater_temp, &
                                 wrf2mz_lt_map,wh2o,wpan,mminlu,month,ixxxlu

  IMPLICIT NONE
CONTAINS
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!  Differentiation of wesely_driver in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: ddvel rmol aer_res_def
!   with respect to varying inputs: ust t_phy znt rmol p_phy moist
!                z_at_w
  SUBROUTINE G_WESELY_DRIVER(id, ktau, dtstep, config_flags, &
&    current_month, gmt, julday, t_phy, g_t_phy, moist, g_moist, p8w, t8w&
&    , raincv, p_phy, g_p_phy, chem, rho_phy, dz8w, ddvel, g_ddvel, &
&    aer_res_def, g_aer_res_def, aer_res_zcen, ivgtyp, tsk, gsw, vegfra, &
&    pbl, rmol, g_rmol, ust, g_ust, znt, g_znt, xlat, xlong, z, z_at_w, &
&    g_z_at_w, snowh, numgas, ids, ide, jds, jde, kds, kde, ims, ime, jms&
&    , jme, kms, kme, its, ite, jts, jte, kts, kte)
    USE module_model_constants
    USE module_configure
    USE module_state_description

    IMPLICIT NONE
!--------------------------------------------------
!  Wesely dry dposition driver
!--------------------------------------------------
    INTEGER, INTENT(IN) :: id, julday, numgas, current_month, ids, ide, &
&    jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte&
&    , kts, kte
    INTEGER, INTENT(IN) :: ktau
    REAL, INTENT(IN) :: dtstep, gmt
!--------------------------------------------------
! advected moisture variables
!--------------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    moist
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    g_moist
!--------------------------------------------------
! advected chemical species
!--------------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: chem
!--------------------------------------------------
! deposition velocities
!--------------------------------------------------
    REAL, DIMENSION(its:ite, jts:jte, num_chem), INTENT(INOUT) :: ddvel
    REAL, DIMENSION(its:ite, jts:jte, num_chem), INTENT(INOUT) :: &
&    g_ddvel
!--------------------------------------------------
! input from met model
!--------------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy, &
&    p_phy, dz8w, z, t8w, p8w, z_at_w, rho_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_t_phy, &
&    g_p_phy, g_z_at_w
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: ivgtyp
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tsk, gsw, vegfra&
&    , pbl, rmol, ust, xlat, xlong, raincv, znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_rmol, g_ust, &
&    g_znt
    REAL, INTENT(INOUT) :: aer_res_def(its:ite, jts:jte)
    REAL, INTENT(INOUT) :: g_aer_res_def(its:ite, jts:jte)
    REAL, INTENT(INOUT) :: aer_res_zcen(its:ite, jts:jte)
    REAL, OPTIONAL, INTENT(IN) :: snowh(ims:ime, jms:jme)
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
!--------------------------------------------------
! .. Local Scalars
!--------------------------------------------------
    REAL :: clwchem, dvfog, dvpart, pa, rad, dep_vap
    REAL :: g_dvpart, g_pa
    REAL :: rhchem, ta, ustar, vegfrac, z1, zntt
    REAL :: g_rhchem, g_ustar, g_z1, g_zntt
    INTEGER :: i, iland, iprt, iseason, j, jce, jcs, n, nr, ipr, jpr, &
&    nvr
    LOGICAL :: highnh3, rainflag, vegflag, wetflag
!--------------------------------------------------
! .. Local Arrays
!--------------------------------------------------
    REAL :: p(kts:kte)
    REAL :: srfres(numgas)
    REAL :: g_srfres(numgas)
    REAL :: ddvel0d(numgas)
    REAL :: g_ddvel0d(numgas)
!-----------------------------------------------------------
! necessary for aerosols (module dependent)         
!-----------------------------------------------------------
    REAL :: rcx(numgas)
    REAL :: g_rcx(numgas)
!-----------------------------------------------------------
! .. Intrinsic Functions
!-----------------------------------------------------------
    REAL :: arg1
    REAL :: g_arg1
    REAL :: g_y1
    REAL :: y1
    dep_vap = config_flags%depo_fact
    !CALL WRF_DEBUG(15, 'in dry_dep_wesely')
    IF (julday .LT. 90 .OR. julday .GT. 270) THEN
      iseason = 2
      !CALL WRF_DEBUG(15, 'setting iseason to 2')
    ELSE
      iseason = 1
    END IF
!    g_ddvel = 0.0_8
!    g_aer_res_def = 0.0_8
    g_srfres = 0.0_8
tile_lat_loop:DO j=jts,jte
tile_lon_loop:DO i=its,ite
        iprt = 0
        iland = luse2usgs(ivgtyp(i, j))
!--
        ta = tsk(i, j)
        rad = gsw(i, j)
        vegfrac = vegfra(i, j)
        g_pa = 0.01*g_p_phy(i, kts, j)
        pa = 0.01*p_phy(i, kts, j)
        clwchem = moist(i, kts, j, p_qc)
        g_ustar = g_ust(i, j)
        ustar = ust(i, j)
        g_zntt = g_znt(i, j)
        zntt = znt(i, j)
        g_z1 = g_z_at_w(i, kts+1, j) - g_z_at_w(i, kts, j)
        z1 = z_at_w(i, kts+1, j) - z_at_w(i, kts, j)
!-----------------------------------------------------------
!     Set logical default values
!-----------------------------------------------------------
        rainflag = .false.
        wetflag = .false.
        highnh3 = .false.
        IF (p_qr .GT. 1) THEN
          IF (moist(i, kts, j, p_qr) .GT. 1.d-18 .OR. raincv(i, j) .GT. &
&              0.D0) rainflag = .true.
        END IF
        g_arg1 = (17.27D0*g_t_phy(i, kts, j)*(t_phy(i, kts, j)-36.D0)-17.27D0*&
&          (t_phy(i, kts, j)-273.D0)*g_t_phy(i, kts, j))/(t_phy(i, kts, j)-&
&          36.D0)**2
        arg1 = 17.27D0*(t_phy(i, kts, j)-273.D0)/(t_phy(i, kts, j)-36.D0)
        g_y1 = (100.D0*g_moist(i, kts, j, p_qv)*3.80D0*EXP(arg1)/pa-100.D0*&
&          moist(i, kts, j, p_qv)*(3.80D0*g_arg1*EXP(arg1)*pa-3.80D0*EXP(arg1&
&          )*g_pa)/pa**2)/(3.80D0*EXP(arg1)/pa)**2
        y1 = 100.D0*moist(i, kts, j, p_qv)/(3.80D0*EXP(arg1)/pa)
        IF (100.D0 .GT. y1) THEN
          g_rhchem = g_y1
          rhchem = y1
        ELSE
          rhchem = 100.D0
          g_rhchem = 0.0_8
        END IF
        IF (5.D0 .LT. rhchem) THEN
          rhchem = rhchem
        ELSE
          rhchem = 5.D0
          g_rhchem = 0.0_8
        END IF
        IF (rhchem .GE. 95.D0) wetflag = .true.
        IF (p_nh3 .GT. 1 .AND. p_so2 .GT. 1) THEN
          IF (chem(i, kts, j, p_nh3) .GT. 2.D0*chem(i, kts, j, p_so2)) &
&            highnh3 = .true.
        END IF
!-----------------------------------------------------------
!--- deposition
!-----------------------------------------------------------
!     if(snowc(i,j).gt.0.)iseason=4
        CALL G_RC(rcx, g_rcx, ta, rad, rhchem, g_rhchem, iland, iseason&
&            , numgas, wetflag, rainflag, highnh3, iprt, moist(i, kts, j&
&            , p_qv), p8w(i, kts, j), config_flags%chem_opt)
        if( config_flags%chem_opt /= MOZART_KPP .and. &
            config_flags%chem_opt /= MOZCART_KPP .and. &
            config_flags%chem_opt /= MOZART_MOSAIC_4BIN_KPP .and. &
            config_flags%chem_opt /= MOZART_MOSAIC_4BIN_AQ_KPP .and. &
            config_flags%chem_opt /= gocart_bc)  then

          g_srfres(1:numgas-2) = g_rcx(1:numgas-2)
          srfres(1:numgas-2) = rcx(1:numgas-2)
          g_srfres(numgas-1:numgas) = 0.0_8
          srfres(numgas-1:numgas) = 0.D0
        ELSE
          g_srfres(1:numgas) = g_rcx(1:numgas)
          srfres(1:numgas) = rcx(1:numgas)
        END IF
        CALL G_DEPPART(rmol(i, j), g_rmol(i, j), ustar, g_ustar, rhchem&
&                 , g_rhchem, clwchem, iland, dvpart, g_dvpart, dvfog)
        ddvel0d(1:numgas) = 0.D0
        g_aer_res_def(i, j) = 0.0_8
        aer_res_def(i, j) = 0.D0
        aer_res_zcen(i, j) = 0.D0
        CALL G_LANDUSEVG(ddvel0d, g_ddvel0d, ustar, g_ustar, rmol(i, j)&
&                   , g_rmol(i, j), zntt, g_zntt, z1, g_z1, dvpart, &
&                   g_dvpart, iland, numgas, srfres, g_srfres, &
&                   aer_res_def(i, j), g_aer_res_def(i, j), aer_res_zcen(&
&                   i, j), p_sulf)
!-----------------------------------------------------------
!wig: CBMZ does not have HO and HO2 last so need to copy all species
!      ddvel(i,j,1:numgas-2)=ddvel0d(1:numgas-2)
!-----------------------------------------------------------
        g_ddvel(i, j, 1:numgas) = g_ddvel0d(1:numgas)
        ddvel(i, j, 1:numgas) = ddvel0d(1:numgas)
      END DO tile_lon_loop
    END DO tile_lat_loop
! For gocartracm,radm
!-----------------------------------------------------------
    IF (config_flags%chem_opt .EQ. gocartracm_kpp .OR. &
&       config_flags%chem_opt .EQ. gocartradm2) THEN
      DO j=jts,jte
        DO i=its,ite
          g_ddvel(i, j, p_sulf) = 0.0_8
          ddvel(i, j, p_sulf) = 0.D0
          g_ddvel(i, j, p_dms) = 0.0_8
          ddvel(i, j, p_dms) = 0.D0
          g_ddvel(i, j, p_msa) = g_ddvel(i, j, p_hno3)
          ddvel(i, j, p_msa) = ddvel(i, j, p_hno3)
          IF (config_flags%chem_opt .EQ. gocartradm2) THEN
            g_ddvel(i, j, p_hcl) = g_ddvel(i, j, p_hno3)
            ddvel(i, j, p_hcl) = ddvel(i, j, p_hno3)
          END IF
        END DO
      END DO
    END IF
!-----------------------------------------------------------
! For gocartsimple : need msa. On the other hand sulf comes from aerosol routine
!-----------------------------------------------------------
    IF (config_flags%chem_opt .EQ. gocart_simple) THEN
      DO j=jts,jte
        DO i=its,ite
          g_ddvel(i, j, p_msa) = g_ddvel(i, j, p_sulf)
          ddvel(i, j, p_msa) = ddvel(i, j, p_sulf)
          g_ddvel(i, j, p_sulf) = 0.0_8
          ddvel(i, j, p_sulf) = 0.D0
          g_ddvel(i, j, p_dms) = 0.0_8
          ddvel(i, j, p_dms) = 0.D0
        END DO
      END DO
    END IF
  END SUBROUTINE G_WESELY_DRIVER

!  Differentiation of rc in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: rcx
!   with respect to varying inputs: rh
  SUBROUTINE G_RC(rcx, g_rcx, t, rad, rh, g_rh, iland, iseason, numgas, &
&    wetflag, rainflag, highnh3, iprt, spec_hum, p_srf, chem_opt)
    USE module_state_description
    IMPLICIT NONE
!----------------------------------------------------------------------
!     THIS SUBROUTINE CALCULATES SURFACE RESISTENCES ACCORDING
!     TO THE MODEL OF
!     M. L. WESELY,
!     ATMOSPHERIC ENVIRONMENT 23 (1989), 1293-1304
!     WITH SOME ADDITIONS ACCORDING TO
!     J. W. ERISMAN, A. VAN PUL, AND P. WYERS,
!     ATMOSPHERIC ENVIRONMENT 28 (1994), 2595-2607
!     WRITTEN BY  WINFRIED SEIDL, APRIL 1997
!     MODYFIED BY WINFRIED SEIDL, MARCH 2000
!                    FOR MM5 VERSION 3
!----------------------------------------------------------------------
!----------------------------------------------------------------------
!	... dummy arguments
!----------------------------------------------------------------------
    INTEGER, INTENT(IN) :: iland, iseason, numgas
    INTEGER, INTENT(IN) :: iprt
    INTEGER, INTENT(IN) :: chem_opt
    REAL, INTENT(IN) :: rad, rh
    REAL, INTENT(IN) :: g_rh
! surface temp (K)
    REAL, INTENT(IN) :: t
! surface pressure (Pa)
    REAL, INTENT(IN) :: p_srf
! surface specific humidity (kg/kg)
    REAL, INTENT(IN) :: spec_hum
    REAL, INTENT(OUT) :: rcx(numgas)
    REAL, INTENT(OUT) :: g_rcx(numgas)
    LOGICAL, INTENT(IN) :: highnh3, rainflag, wetflag
!----------------------------------------------------------------------
! .. Local Scalars ..
!----------------------------------------------------------------------
    REAL, PARAMETER :: t0=298.D0
    REAL, PARAMETER :: tmelt=273.16D0
    INTEGER :: lt, n
    REAL :: rclx, rdc, resice, rgsx, rluo1, rluo2
    REAL :: rlux, rmx, rs, rsmx, rdtheta, z, wrk
    REAL :: g_rlux
    REAL :: qs, es, ws, dewm, dv_pan, drat
    REAL :: crs, tc
    REAL :: rs_pan, tc_pan
    LOGICAL :: has_dew
!----------------------------------------------------------------------
! .. Local Arrays ..
!----------------------------------------------------------------------
    REAL :: hstary(numgas)
    REAL :: g_hstary(numgas)
!----------------------------------------------------------------------
! .. Intrinsic Functions ..
!----------------------------------------------------------------------
    INTRINSIC EXP
    INTRINSIC MAX
    rcx(1:numgas) = 1.D0
    tc = t - 273.15D0
    rdtheta = 0.D0
    z = 200.D0/(rad+0.1D0)
!!!  HARDWIRE VALUES FOR TESTING
!       z=0.4727409
!       tc=22.76083
!       t=tc+273.15
!       rad = 412.8426
!       rainflag=.false.
!       wetflag=.false.
    IF (tc .LE. 0.D0 .OR. tc .GE. 40.D0) THEN
      rs = 9999.D0
    ELSE
      rs = ri(iland, iseason)*(1.D0+z*z)*(400.D0/(tc*(40.D0-tc)))
    END IF
    rdc = 100.D0*(1.D0+1000.D0/(rad+10.D0))/(1.D0+1000.D0*rdtheta)
    rluo1 = 1.D0/(1.D0/3000.D0+3.D0/rlu(iland, iseason))
    rluo2 = 1.D0/(1.D0/1000.D0+3.D0/rlu(iland, iseason))
    resice = 1000.D0*EXP(-(tc+4.D0))
    wrk = (t0-t)/(t0*t)
    DO n=1,numgas
      IF (hstar(n) .NE. 0.) THEN
        g_hstary(n) = 0.0_8
        hstary(n) = hstar(n)*EXP(dhr(n)*wrk)
        rmx = 1.D0/(hstary(n)/3000.D0+100.D0*f0(n))
        rsmx = rs*dratio(n) + rmx
        rclx = 1.D0/(1.d-5*hstary(n)/rcls(iland, iseason)+f0(n)/rclo(iland&
&          , iseason)) + resice
        rgsx = 1.D0/(1.d-5*hstary(n)/rgss(iland, iseason)+f0(n)/rgso(iland&
&          , iseason)) + resice
        rlux = rlu(iland, iseason)/(1.d-5*hstary(n)+f0(n)) + resice
        IF (wetflag) rlux = 1.D0/(1.D0/(3.D0*rlu(iland, iseason))+1.d-7*hstary&
&            (n)+f0(n)/rluo1)
        IF (rainflag) rlux = 1.D0/(1.D0/(3.D0*rlu(iland, iseason))+1.d-7*&
&            hstary(n)+f0(n)/rluo2)
        g_rcx(n) = 0.0_8
        rcx(n) = 1.D0/(1.D0/rsmx+1.D0/rlux+1.D0/(rdc+rclx)+1.D0/(rac(iland, &
&          iseason)+rgsx))
        IF (1.D0 .LT. rcx(n)) THEN
          g_rcx(n) = 0.0_8
          rcx(n) = rcx(n)
        ELSE
          g_rcx(n) = 0.0_8
          rcx(n) = 1.D0
        END IF
      END IF
    END DO
!--------------------------------------------------
!     SO2 according to Erisman et al. 1994
!       R_STOM
!--------------------------------------------------
    IF (p_so2 .GT. 1) THEN
      rsmx = rs*dratio(p_so2)
!--------------------------------------------------
!       R_EXT
!--------------------------------------------------
      IF (tc .GT. -1.) THEN
        IF (rh .LT. 81.3) THEN
          g_rlux = -(25000.D0*0.0693D0*g_rh*EXP(-(0.0693D0*rh)))
          rlux = 25000.D0*EXP(-(0.0693D0*rh))
        ELSE
          g_rlux = -(0.58d12*0.278D0*g_rh*EXP(-(0.278D0*rh)))
          rlux = 0.58d12*EXP(-(0.278D0*rh))
        END IF
      ELSE
        g_rlux = 0.0_8
      END IF
      IF ((wetflag .OR. rainflag) .AND. tc .GT. -1.) THEN
        rlux = 1.D0
        g_rlux = 0.0_8
      END IF
      IF (tc .GE. -5.D0 .AND. tc .LE. -1.D0) THEN
        rlux = 200.D0
        g_rlux = 0.0_8
      END IF
      IF (tc .LT. -5.D0) THEN
        rlux = 500.D0
        g_rlux = 0.0_8
      END IF
!--------------------------------------------------
!       INSTEAD OF R_INC R_CL and R_DC of Wesely are used
!--------------------------------------------------
      rclx = rcls(iland, iseason)
!--------------------------------------------------
!       DRY SURFACE
!--------------------------------------------------
      rgsx = 1000.D0
!--------------------------------------------------
!       WET SURFACE
!--------------------------------------------------
      IF (wetflag .OR. rainflag) THEN
        IF (highnh3) THEN
          rgsx = 0.D0
        ELSE
          rgsx = 500.D0
        END IF
      END IF
!--------------------------------------------------
!       WATER
!--------------------------------------------------
      IF (iland .EQ. iswater_temp) rgsx = 0.
!--------------------------------------------------
!       SNOW
!--------------------------------------------------
      IF (iseason .EQ. 4 .OR. iland .EQ. isice_temp) THEN
        IF (tc .GT. 2.) THEN
          rgsx = 0.
        ELSE IF (tc .GE. -1. .AND. tc .LE. 2.) THEN
          rgsx = 70.D0*(2.D0-tc)
        ELSE IF (tc .LT. -1.) THEN
          rgsx = 500.D0
        END IF
      END IF
!--------------------------------------------------
!       TOTAL SURFACE RESISTENCE
!--------------------------------------------------
      IF (iseason .NE. 4 .AND. ixxxlu(iland) .NE. 1 .AND. iland .NE. &
&          iswater_temp .AND. iland .NE. isice_temp) THEN
        g_rcx = 0.0_8
        g_rcx(p_so2) = -((-(g_rlux/rlux**2))/(1.D0/rsmx+1.D0/rlux+1.D0/(rclx+&
&          rdc+rgsx))**2)
        rcx(p_so2) = 1.D0/(1.D0/rsmx+1.D0/rlux+1.D0/(rclx+rdc+rgsx))
      ELSE
        g_rcx(p_so2) = 0.0_8
        rcx(p_so2) = rgsx
        g_rcx = 0.0_8
      END IF
      IF (1.D0 .LT. rcx(p_so2)) THEN
        rcx(p_so2) = rcx(p_so2)
      ELSE
        g_rcx(p_so2) = 0.0_8
        rcx(p_so2) = 1.D0
      END IF
    ELSE
      g_rcx = 0.0_8
    END IF
  END SUBROUTINE G_RC

!  Differentiation of deppart in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: dvpart
!   with respect to varying inputs: ustar rh rmol
  SUBROUTINE G_DEPPART(rmol, g_rmol, ustar, g_ustar, rh, g_rh, clw, &
&    iland, dvpart, g_dvpart, dvfog)
    IMPLICIT NONE
!--------------------------------------------------
!     THIS SUBROUTINE CALCULATES SURFACE DEPOSITION VELOCITIES
!     FOR FINE AEROSOL PARTICLES ACCORDING TO THE MODEL OF
!     J. W. ERISMAN, A. VAN PUL, AND P. WYERS,
!     ATMOSPHERIC ENVIRONMENT 28 (1994), 2595-2607
!     WRITTEN BY WINFRIED SEIDL, APRIL 1997
!     MODIFIED BY WINFRIED SEIDL, MARCH 2000
!            FOR MM5 VERSION 3
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: iland
    REAL, INTENT(IN) :: clw, rh, rmol, ustar
    REAL, INTENT(IN) :: g_rh, g_rmol, g_ustar
    REAL, INTENT(OUT) :: dvfog, dvpart
    REAL, INTENT(OUT) :: g_dvpart
!--------------------------------------------------
! .. Intrinsic Functions ..
!--------------------------------------------------
    INTRINSIC EXP
    g_dvpart = g_ustar/kpart(iland)
    dvpart = ustar/kpart(iland)
    IF (rmol .LT. 0.) THEN
!--------------------------------------------------
!         UNSTABLE LAYERING CORRECTION
!--------------------------------------------------
      g_dvpart = g_dvpart*(1.D0+(-(300.D0*rmol))**0.66667D0) - dvpart*0.66667D0*&
&        (-(300.D0*rmol))**(-0.33333D0)*300.D0*g_rmol
      dvpart = dvpart*(1.D0+(-(300.D0*rmol))**0.66667D0)
    END IF
    IF (rh .GT. 80.) THEN
!--------------------------------------------------
!         HIGH RELATIVE HUMIDITY CORRECTION
!         ACCORDING TO J. W. ERISMAN ET AL.
!         ATMOSPHERIC ENVIRONMENT 31 (1997), 321-332
!--------------------------------------------------
      g_dvpart = g_dvpart*(1.D0+0.37D0*EXP((rh-80.D0)/20.D0)) + dvpart*0.37D0*g_rh&
&        *EXP((rh-80.D0)/20.D0)/20.D0
      dvpart = dvpart*(1.D0+0.37D0*EXP((rh-80.D0)/20.D0))
    END IF
!--------------------------------------------------
!       SEDIMENTATION VELOCITY OF FOG WATER ACCORDING TO
!       R. FORKEL, W. SEIDL, R. DLUGI AND E. DEIGELE
!       J. GEOPHYS. RES. 95D (1990), 18501-18515
!--------------------------------------------------
    dvfog = 0.06D0*clw
    IF (ixxxlu(iland) .EQ. 5) dvfog = dvfog + 0.195D0*ustar*ustar
!--------------------------------------------------
!         TURBULENT DEPOSITION OF FOG WATER IN CONIFEROUS FOREST ACCORDI
!         A. T. VERMEULEN ET AL.
!         ATMOSPHERIC ENVIRONMENT 31 (1997), 375-386
!--------------------------------------------------
  END SUBROUTINE G_DEPPART

!  Differentiation of landusevg in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: vgs rmol aer_res_def
!   with respect to varying inputs: zz ustar z0 srfres dvparx rmol
  SUBROUTINE G_LANDUSEVG(vgs, g_vgs, ustar, g_ustar, rmol, g_rmol, z0, &
&    g_z0, zz, g_zz, dvparx, g_dvparx, iland, numgas, srfres, g_srfres, &
&    aer_res_def, g_aer_res_def, aer_res_zcen, p_sulf)
    USE module_model_constants, ONLY : karman
    IMPLICIT NONE
!--------------------------------------------------
!     This subroutine calculates the species specific deposition velocit
!     as a function of the local meteorology and land use.  The depositi
!     Velocity is also landuse specific.
!     Reference: Hsieh, C.M., Wesely, M.L. and Walcek, C.J. (1986)
!                A Dry Deposition Module for Regional Acid Deposition
!                EPA report under agreement DW89930060-01
!     Revised version by Darrell Winner (January 1991)
!        Environmental Engineering Science 138-78
!           California Institute of Technology
!              Pasadena, CA  91125
!     Modified by Winfried Seidl (August 1997)
!       Fraunhofer-Institut fuer Atmosphaerische Umweltforschung
!                    Garmisch-Partenkirchen, D-82467
!          for use of Wesely and Erisman surface resistances
!     Inputs:
!        Ustar  : The grid average friction velocity (m/s)
!        Rmol   : Reciprocal of the Monin-Obukhov length (1/m)
!        Z0     : Surface roughness height for the grid square (m)
!        SrfRes : Array of landuse/atmospheric/species resistances (s/m)
!        Slist  : Array of chemical species codes
!        Dvparx : Array of surface deposition velocity of fine aerosol p
!     Outputs:
!        Vgs    : Array of species and landuse specific deposition
!                 velocities (m/s)
!        Vg     : Cell-average deposition velocity by species (m/s)
!     Variables used:
!        SCPR23  : (Schmidt #/Prandtl #)**(2/3) Diffusion correction fac
!        Zr      : Reference Height (m)
!        Iatmo   : Parameter specifying the stabilty class (Function of
!        Z0      : Surface roughness height (m)
!        karman  : Von Karman constant (from module_model_constants)
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: iland, numgas, p_sulf
    REAL, INTENT(IN) :: dvparx, ustar, z0, zz
    REAL, INTENT(IN) :: g_dvparx, g_ustar, g_z0, g_zz
    REAL, INTENT(INOUT) :: rmol
    REAL, INTENT(INOUT) :: g_rmol
    REAL, INTENT(INOUT) :: aer_res_def
    REAL, INTENT(INOUT) :: g_aer_res_def
    REAL, INTENT(INOUT) :: aer_res_zcen
    REAL :: g_aer_res_zcen
!--------------------------------------------------
! .. Array Arguments ..
!--------------------------------------------------
    REAL, INTENT(IN) :: srfres(numgas)
    REAL, INTENT(IN) :: g_srfres(numgas)
    REAL, INTENT(OUT) :: vgs(numgas)
    REAL, INTENT(OUT) :: g_vgs(numgas)
!--------------------------------------------------
! .. Local Scalars ..
!--------------------------------------------------
    INTEGER :: jspec
    REAL :: vgp, vgpart, zr
    REAL :: g_vgp, g_vgpart, g_zr
    REAL :: rmol_tmp
    REAL :: g_rmol_tmp
!--------------------------------------------------
! .. Local Arrays ..
!--------------------------------------------------
    REAL :: vgspec(numgas)
    REAL :: g_vgspec(numgas)
!--------------------------------------------------
!   Calculate aerodynamic resistance for reference
!   height = layer center
!--------------------------------------------------
    g_zr = .5D0*g_zz
    zr = zz*.5D0
    g_rmol_tmp = g_rmol
    rmol_tmp = rmol
    g_vgspec = 0.0_8
    CALL G_DEPVEL(numgas, rmol_tmp, g_rmol_tmp, zr, g_zr, z0, g_z0, &
&            ustar, g_ustar, vgspec, g_vgspec, vgpart, g_vgpart, &
&            aer_res_zcen, g_aer_res_zcen)
!--------------------------------------------------
!   Set the reference height (2.0 m)
!--------------------------------------------------
!       zr = 10.0
    zr = 2.0D0
!--------------------------------------------------
!   CALCULATE THE DEPOSITION VELOCITY without any surface
!   resistance term, i.e. 1 / (ra + rb)
!--------------------------------------------------
    g_zr = 0.0_8
    CALL G_DEPVEL(numgas, rmol, g_rmol, zr, g_zr, z0, g_z0, ustar, &
&            g_ustar, vgspec, g_vgspec, vgpart, g_vgpart, aer_res_def, &
&            g_aer_res_def)
!--------------------------------------------------
!   Calculate the deposition velocity for each species
!   and grid cell by looping through all the possibile combinations
!   of the two
!--------------------------------------------------
    g_vgp = -((-(g_vgpart/vgpart**2)-g_dvparx/dvparx**2)/(1.0D0/vgpart+1.0D0&
&      /dvparx)**2)
    vgp = 1.0D0/(1.0D0/vgpart+1.0D0/dvparx)
    g_vgs = 0.0_8
!--------------------------------------------------
!   Loop through the various species
!--------------------------------------------------
    DO jspec=1,numgas
!--------------------------------------------------
!   Add in the surface resistance term, rc (SrfRes)
!--------------------------------------------------
      g_vgs(jspec) = -((g_srfres(jspec)-g_vgspec(jspec)/vgspec(jspec)**2&
&        )/(1.0D0/vgspec(jspec)+srfres(jspec))**2)
      vgs(jspec) = 1.0D0/(1.0D0/vgspec(jspec)+srfres(jspec))
    END DO
    g_vgs(p_sulf) = g_vgp
    vgs(p_sulf) = vgp
    CALL G_CELLVG(vgs, g_vgs, ustar, g_ustar, zz, g_zz, zr, rmol, g_rmol&
&            , numgas)
  END SUBROUTINE G_LANDUSEVG

!  Differentiation of cellvg in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: vgtemp
!   with respect to varying inputs: ustar dz rmol vgtemp
  SUBROUTINE G_CELLVG(vgtemp, g_vgtemp, ustar, g_ustar, dz, g_dz, zr, &
&    rmol, g_rmol, nspec)
    USE module_model_constants, ONLY : karman
    IMPLICIT NONE
!--------------------------------------------------
!     THIS PROGRAM HAS BEEN DESIGNED TO CALCULATE THE CELL AVERAGE
!     DEPOSITION VELOCITY GIVEN THE VALUE OF VG AT SOME REFERENCE
!     HEIGHT ZR WHICH IS MUCH SMALLER THAN THE CELL HEIGHT DZ.
!       PROGRAM WRITTEN BY GREGORY J.MCRAE (NOVEMBER 1977)
!         Modified by Darrell A. Winner    (February 1991)
!.....PROGRAM VARIABLES...
!     VgTemp   - DEPOSITION VELOCITY AT THE REFERENCE HEIGHT
!     USTAR    - FRICTION VELOCITY
!     RMOL     - RECIPROCAL OF THE MONIN-OBUKHOV LENGTH
!     ZR       - REFERENCE HEIGHT
!     DZ       - CELL HEIGHT
!     CELLVG   - CELL AVERAGE DEPOSITION VELOCITY
!     VK       - VON KARMAN CONSTANT
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: nspec
    REAL, INTENT(IN) :: dz, rmol, ustar, zr
    REAL, INTENT(IN) :: g_dz, g_rmol, g_ustar
!--------------------------------------------------
! .. Array Arguments ..
!--------------------------------------------------
    REAL, INTENT(OUT) :: vgtemp(nspec)
    REAL, INTENT(OUT) :: g_vgtemp(nspec)
!--------------------------------------------------
! .. Local Scalars ..
!--------------------------------------------------
    INTEGER :: nss
    REAL :: a, fac, pdz, pzr, vk
    REAL :: g_a, g_fac, g_pdz, g_pzr
!--------------------------------------------------
! .. Intrinsic Functions ..
!--------------------------------------------------
    INTRINSIC ALOG, SQRT
    REAL :: arg1
    REAL :: g_arg1
!--------------------------------------------------
!     Set the von Karman constant
!--------------------------------------------------
    vk = karman
!--------------------------------------------------
!     DETERMINE THE STABILITY BASED ON THE CONDITIONS
!             1/L < 0 UNSTABLE
!             1/L = 0 NEUTRAL
!             1/L > 0 STABLE
!--------------------------------------------------
    DO nss=1,nspec
      IF (rmol .LT. 0.) THEN
        g_arg1 = -(9.0D0*(g_dz*rmol+dz*g_rmol))
        arg1 = 1.0D0 - 9.0D0*dz*rmol
        IF (arg1 .EQ. 0.0_8) THEN
          g_pdz = 0.0_8
        ELSE
          g_pdz = g_arg1/(2.0D0*SQRT(arg1))
        END IF
        pdz = SQRT(arg1)
        g_arg1 = -(9.0D0*zr*g_rmol)
        arg1 = 1.0D0 - 9.0D0*zr*rmol
        IF (arg1 .EQ. 0.0_8) THEN
          g_pzr = 0.0_8
        ELSE
          g_pzr = g_arg1/(2.0D0*SQRT(arg1))
        END IF
        pzr = SQRT(arg1)
        g_fac = (g_pdz*(pzr-1.0D0)-(pdz-1.0D0)*g_pzr)*(pzr+1.0D0)/((pzr-1.0D0)**&
&          2*(pdz+1.0D0)) + (pdz-1.0D0)*(g_pzr*(pdz+1.0D0)-(pzr+1.0D0)*g_pdz)/((&
&          pzr-1.0D0)*(pdz+1.0D0)**2)
        fac = (pdz-1.0D0)/(pzr-1.0D0)*((pzr+1.0D0)/(pdz+1.0D0))
        g_a = 0.74D0*(g_dz*ALOG(fac)+dz*g_fac/fac) + 0.164D0*(g_pdz-g_pzr)/&
&          rmol - 0.164D0*g_rmol*(pdz-pzr)/rmol**2
        a = 0.74D0*dz*ALOG(fac) + 0.164D0/rmol*(pdz-pzr)
      ELSE IF (rmol .EQ. 0.) THEN
        g_a = 0.74D0*g_dz*ALOG(dz/zr)
        a = 0.74D0*(dz*ALOG(dz/zr)-dz+zr)
      ELSE
        g_a = 0.74D0*g_dz*ALOG(dz/zr) + 2.35D0*(g_rmol*(dz-zr)**2+rmol*2*(dz&
&          -zr)*g_dz)
        a = 0.74D0*(dz*ALOG(dz/zr)-dz+zr) + 2.35D0*rmol*(dz-zr)**2
      END IF
!--------------------------------------------------
!     CALCULATE THE DEPOSITION VELOCITIY
!--------------------------------------------------
      g_vgtemp(nss) = (g_vgtemp(nss)*(1.0D0+vgtemp(nss)*a/(vk*ustar*(dz-zr&
&        )))-vgtemp(nss)*((g_vgtemp(nss)*a+vgtemp(nss)*g_a)*vk*ustar*(dz-&
&        zr)-vgtemp(nss)*a*vk*(g_ustar*(dz-zr)+ustar*g_dz))/(vk**2*ustar&
&        **2*(dz-zr)**2))/(1.0D0+vgtemp(nss)*a/(vk*ustar*(dz-zr)))**2
      vgtemp(nss) = vgtemp(nss)/(1.0D0+vgtemp(nss)*a/(vk*ustar*(dz-zr)))
    END DO
  END SUBROUTINE G_CELLVG

!  Differentiation of depvel in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: aer_res vgpart depv rmol
!   with respect to varying inputs: ustar z0 depv rmol zr
  SUBROUTINE G_DEPVEL(numgas, rmol, g_rmol, zr, g_zr, z0, g_z0, ustar, &
&    g_ustar, depv, g_depv, vgpart, g_vgpart, aer_res, g_aer_res)
    USE module_model_constants, ONLY : karman
    IMPLICIT NONE
!--------------------------------------------------
!     THIS FUNCTION HAS BEEN DESIGNED TO EVALUATE AN UPPER LIMIT
!     FOR THE POLLUTANT DEPOSITION VELOCITY AS A FUNCTION OF THE
!     SURFACE ROUGHNESS AND METEOROLOGICAL CONDITIONS.
!     PROGRAM WRITTEN BY GREGORY J.MCRAE (NOVEMBER 1977)
!         Modified by Darrell A. Winner  (Feb. 1991)
!                  by Winfried Seidl     (Aug. 1997)
!.....PROGRAM VARIABLES...
!     RMOL     - RECIPROCAL OF THE MONIN-OBUKHOV LENGTH
!     ZR       - REFERENCE HEIGHT
!     Z0       - SURFACE ROUGHNESS HEIGHT
!     SCPR23   - (Schmidt #/Prandtl #)**(2/3) Diffusion correction fact
!     UBAR     - ABSOLUTE VALUE OF SURFACE WIND SPEED
!     DEPVEL   - POLLUTANT DEPOSITION VELOCITY
!     Vk       - VON KARMAN CONSTANT
!     USTAR    - FRICTION VELOCITY U*
!     POLINT   - POLLUTANT INTEGRAL
!     AER_RES  - AERODYNAMIC RESISTANCE
!.....REFERENCES...
!     MCRAE, G.J. ET AL. (1983) MATHEMATICAL MODELING OF PHOTOCHEMICAL
!       AIR POLLUTION, ENVIRONMENTAL QUALITY LABORATORY REPORT 18,
!       CALIFORNIA INSTITUTE OF TECHNOLOGY, PASADENA, CALIFORNIA.
!.....RESTRICTIONS...
!     1. THE MODEL EDDY DIFFUSIVITIES ARE BASED ON MONIN-OBUKHOV
!        SIMILARITY THEORY AND SO ARE ONLY APPLICABLE IN THE
!        SURFACE LAYER, A HEIGHT OF O(30M).
!     2. ALL INPUT UNITS MUST BE CONSISTENT
!     3. THE PHI FUNCTIONS USED TO CALCULATE THE FRICTION
!        VELOCITY U* AND THE POLLUTANT INTEGRALS ARE BASED
!        ON THE WORK OF BUSINGER ET AL.(1971).
!     4. THE MOMENTUM AND POLLUTANT DIFFUSIVITIES ARE NOT
!        THE SAME FOR THE CASES L<0 AND L>0.
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: numgas
    REAL, INTENT(IN) :: ustar, z0, zr
    REAL, INTENT(IN) :: g_ustar, g_z0, g_zr
    REAL, INTENT(OUT) :: vgpart, aer_res
    REAL, INTENT(OUT) :: g_vgpart, g_aer_res
    REAL, INTENT(INOUT) :: rmol
    REAL, INTENT(INOUT) :: g_rmol
!--------------------------------------------------
! .. Array Arguments ..
!--------------------------------------------------
    REAL, INTENT(OUT) :: depv(numgas)
    REAL, INTENT(OUT) :: g_depv(numgas)
!--------------------------------------------------
! .. Local Scalars ..
!--------------------------------------------------
    INTEGER :: l
    REAL :: ao, ar, polint, vk
    REAL :: g_ao, g_ar, g_polint
!--------------------------------------------------
! .. Intrinsic Functions ..
!--------------------------------------------------
    INTRINSIC ALOG
    REAL :: arg1
    REAL :: g_arg1
    REAL :: arg2
    REAL :: g_arg2
    INTRINSIC MAX
    INTRINSIC ABS
    REAL :: g_max2
    REAL :: abs0
    REAL :: max2
!--------------------------------------------------
!     Set the von Karman constant
!--------------------------------------------------
    vk = karman
    IF (rmol .GE. 0.) THEN
      abs0 = rmol
    ELSE
      abs0 = -rmol
    END IF
!--------------------------------------------------
!     Calculate the diffusion correction factor
!     SCPR23 is calculated as (Sc/Pr)**(2/3) using Sc= 1.15 and Pr= 1.0
!     SCPR23 = 1.10
!--------------------------------------------------
!     DETERMINE THE STABILITY BASED ON THE CONDITIONS
!             1/L < 0 UNSTABLE
!             1/L = 0 NEUTRAL
!             1/L > 0 STABLE
!--------------------------------------------------
    IF (abs0 .LT. 1.d-6) THEN
      rmol = 0.D0
      g_rmol = 0.0_8
    END IF
    IF (rmol .LT. 0) THEN
      g_ar = -(2.D0*((1.0D0-9.0D0*zr*rmol)**0.25D0+0.001D0)*0.25D0*(1.0D0-9.0D0*zr*rmol)&
&        **(-0.75D0)*9.0D0*(g_zr*rmol+zr*g_rmol))
      ar = ((1.0D0-9.0D0*zr*rmol)**0.25D0+0.001D0)**2
      g_ao = -(2.D0*((1.0D0-9.0D0*z0*rmol)**0.25D0+0.001D0)*0.25D0*(1.0D0-9.0D0*z0*rmol)&
&        **(-0.75D0)*9.0D0*(g_z0*rmol+z0*g_rmol))
      ao = ((1.0D0-9.0D0*z0*rmol)**0.25D0+0.001D0)**2
      g_arg1 = (g_ar*(ar+1.0D0)-(ar-1.0D0)*g_ar)/(ar+1.0D0)**2
      arg1 = (ar-1.0D0)/(ar+1.0D0)
      g_arg2 = (g_ao*(ao+1.0D0)-(ao-1.0D0)*g_ao)/(ao+1.0D0)**2
      arg2 = (ao-1.0D0)/(ao+1.0D0)
      g_polint = 0.74D0*(g_arg1/arg1-g_arg2/arg2)
      polint = 0.74D0*(ALOG(arg1)-ALOG(arg2))
    ELSE IF (rmol .EQ. 0.) THEN
      g_polint = 0.74D0*(g_zr*z0-zr*g_z0)/(z0*zr)
      polint = 0.74D0*ALOG(zr/z0)
    ELSE
      g_polint = 0.74D0*(g_zr*z0-zr*g_z0)/(z0*zr) + 4.7D0*(g_rmol*(zr-z0)+&
&        rmol*(g_zr-g_z0))
      polint = 0.74D0*ALOG(zr/z0) + 4.7D0*rmol*(zr-z0)
    END IF
!--------------------------------------------------
!     CALCULATE THE Maximum DEPOSITION VELOCITY
!--------------------------------------------------
    DO l=1,numgas
      g_depv(l) = (vk*g_ustar*(2.0D0*scpr23(l)+polint)-ustar*vk*g_polint)/&
&        (2.0D0*scpr23(l)+polint)**2
      depv(l) = ustar*vk/(2.0D0*scpr23(l)+polint)
    END DO
    g_vgpart = (vk*g_ustar*polint-ustar*vk*g_polint)/polint**2
    vgpart = ustar*vk/polint
    IF (ustar .LT. 1.0d-4) THEN
      max2 = 1.0d-4
      g_max2 = 0.0_8
    ELSE
      g_max2 = g_ustar
      max2 = ustar
    END IF
    g_aer_res = (g_polint*karman*max2-polint*karman*g_max2)/(karman*max2&
&      )**2
    aer_res = polint/(karman*max2)
  END SUBROUTINE G_DEPVEL

END MODULE G_MODULE_DEP_SIMPLE
