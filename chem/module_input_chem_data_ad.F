!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!dis
!dis    Open Source License/Disclaimer, Forecast Systems Laboratory
!dis    NOAA/OAR/FSL, 325 Broadway Boulder, CO 80305
!dis    
!dis    This software is distributed under the Open Source Definition,
!dis    which may be found at http://www.opensource.org/osd.html.
!dis    
!dis    In particular, redistribution and use in source and binary forms,
!dis    with or without modification, are permitted provided that the
!dis    following conditions are met:
!dis    
!dis    - Redistributions of source code must retain this notice, this
!dis    list of conditions and the following disclaimer.
!dis    
!dis    - Redistributions in binary form must provide access to this
!dis    notice, this list of conditions and the following disclaimer, and
!dis    the underlying source code.
!dis    
!dis    - All modifications to this software must be clearly documented,
!dis    and are solely the responsibility of the agent making the
!dis    modifications.
!dis    
!dis    - If significant modifications or enhancements are made to this
!dis    software, the FSL Software Policy Manager
!dis    (softwaremgr@fsl.noaa.gov) should be notified.
!dis    
!dis    THIS SOFTWARE AND ITS DOCUMENTATION ARE IN THE PUBLIC DOMAIN
!dis    AND ARE FURNISHED "AS IS."  THE AUTHORS, THE UNITED STATES
!dis    GOVERNMENT, ITS INSTRUMENTALITIES, OFFICERS, EMPLOYEES, AND
!dis    AGENTS MAKE NO WARRANTY, EXPRESS OR IMPLIED, AS TO THE USEFULNESS
!dis    OF THE SOFTWARE AND DOCUMENTATION FOR ANY PURPOSE.  THEY ASSUME
!dis    NO RESPONSIBILITY (1) FOR THE USE OF THE SOFTWARE AND
!dis    DOCUMENTATION; OR (2) TO PROVIDE TECHNICAL SUPPORT TO USERS.
!dis   
!dis 
!WRF:PACKAGE:IO
MODULE a_module_input_chem_data
  USE module_io_domain
  USE module_domain
  USE module_data_sorgam, ONLY : conmin, rgasuniv, epsilc
  USE module_input_chem_data, ONLY: get_last_gas, bdy_chem_value_sorgam
  IMPLICIT NONE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  REAL, PARAMETER :: mwso4=96.0576
! Initial atmospheric chemistry profile data
! Used for loop index
  INTEGER :: k_loop
! number of chemicals in inital profile
  INTEGER :: lo
! number of final chemical species (nch-1)
  INTEGER :: logg
! number of vertical levels in temp profile        
  INTEGER :: kx
  INTEGER :: kxm1
  PARAMETER (kx=16, kxm1=kx-1, logg=200, lo=34)
! Changed value of logg from 100 to 200 for additional gas species
  INTEGER, DIMENSION(logg) :: iref
  REAL, DIMENSION(logg) :: fracref
  REAL, DIMENSION(kx) :: dens
  REAL, DIMENSION(kx + 1) :: zfa
  REAL, DIMENSION(kx + 1) :: zfa_bdy
  REAL, DIMENSION(lo, kx) :: xl
  REAL :: so4vaptoaer
  CHARACTER(len=4), DIMENSION(logg) :: ggnam
  TYPE LBC_CONCENTRATION
      REAL, POINTER :: ch4_lbc(:, :)
      REAL, POINTER :: n2o_lbc(:, :)
      REAL, POINTER :: h2_lbc(:, :)
      LOGICAL :: is_allocated
  END TYPE LBC_CONCENTRATION
  TYPE(LBC_CONCENTRATION), ALLOCATABLE :: fixed_lbc(:)
! NOx (NO+NO2)
  DATA (xl(34, k_loop), k_loop=1,kx) /1.94e+09, 1.94e+09, 1.53e+09, &
&       1.24e+09, 1.04e+09, 8.96e+08, 7.94e+08, 7.11e+08, 6.44e+08, &
&       6.00e+08, 5.70e+08, 5.49e+08, 5.35e+08, 5.28e+08, 5.24e+08, &
&       5.23e+08/
! O3 <--This is not the O3 used for RADM2 or CBMZ (wig)
  DATA (xl(33, k_loop), k_loop=1,kx) /8.36e+11, 8.36e+11, 4.26e+11, &
&       4.96e+11, 6.05e+11, 6.93e+11, 7.40e+11, 7.74e+11, 7.82e+11, &
&       7.75e+11, 7.69e+11, 7.59e+11, 7.54e+11, 7.50e+11, 7.47e+11, &
&       7.45e+11/
! Sum of RO2 &
  DATA (xl(32, k_loop), k_loop=1,kx) /9.14e+06, 9.14e+06, 1.46e+07, &
&       2.14e+07, 2.76e+07, 3.62e+07, 5.47e+07, 1.19e+08, 2.05e+08, &
&       2.25e+08, 2.39e+08, 2.58e+08, 2.82e+08, 2.99e+08, 3.08e+08, &
&       3.15e+08/
! HO2NO2
  DATA (xl(31, k_loop), k_loop=1,kx) /7.25e+07, 7.25e+07, 6.36e+07, &
&       5.55e+07, 4.94e+07, 3.66e+07, 2.01e+07, 9.57e+06, 4.75e+06, &
&       2.37e+06, 1.62e+06, 9.86e+05, 7.05e+05, 5.63e+05, 4.86e+05, &
&       4.41e+05/
! NO3+N2O5
  DATA (xl(30, k_loop), k_loop=1,kx) /5.52e+05, 5.52e+05, 3.04e+05, &
&       2.68e+05, 2.32e+05, 1.66e+05, 1.57e+05, 1.72e+05, 1.98e+05, &
&       2.22e+05, 2.43e+05, 2.75e+05, 3.00e+05, 3.18e+05, 3.32e+05, &
&       3.39e+05/
! HO2
  DATA (xl(29, k_loop), k_loop=1,kx) /5.74e+07, 5.74e+07, 7.42e+07, &
&       8.38e+07, 8.87e+07, 9.76e+07, 1.15e+08, 1.34e+08, 1.46e+08, &
&       1.44e+08, 1.40e+08, 1.36e+08, 1.31e+08, 1.28e+08, 1.26e+08, &
&       1.26e+08/
! OH
  DATA (xl(28, k_loop), k_loop=1,kx) /9.80e+06, 9.80e+06, 4.89e+06, &
&       2.42e+06, 1.37e+06, 9.18e+05, 7.29e+05, 6.26e+05, 5.01e+05, &
&       4.33e+05, 4.05e+05, 3.27e+05, 2.54e+05, 2.03e+05, 1.74e+05, &
&       1.52e+05/
! Acetylene - Gregory PEM-West A 53 ppt median marine boundary layer
  DATA (xl(27, k_loop), k_loop=1,kx) /1.00e-12, 2.48e-12, 4.42e-12, &
&       6.53e-12, 9.42e-12, 1.33e-11, 1.81e-11, 2.37e-11, 2.95e-11, &
&       3.44e-11, 3.85e-11, 4.22e-11, 4.49e-11, 4.69e-11, 4.84e-11, &
&       4.95e-11/
! Propane - Gregory PEM-West A 25 ppt median marine boundary layer
  DATA (xl(26, k_loop), k_loop=1,kx) /5.00e-13, 1.24e-12, 2.21e-12, &
&       3.27e-12, 4.71e-12, 6.64e-12, 9.06e-12, 1.19e-11, 1.47e-11, &
&       1.72e-11, 1.93e-11, 2.11e-11, 2.24e-11, 2.34e-11, 2.42e-11, &
&       2.48e-11/
  DATA (xl(25, k_loop), k_loop=1,kx) /kx*1.e-20/
  DATA (xl(24, k_loop), k_loop=1,kx) /kx*1.e-20/
  DATA (xl(23, k_loop), k_loop=1,kx) /kx*1.e-20/
  DATA (xl(22, k_loop), k_loop=1,kx) /kx*1.e-20/
  DATA (xl(21, k_loop), k_loop=1,kx) /kx*1.e-20/
  DATA (xl(20, k_loop), k_loop=1,kx) /kx*1.e-20/
  DATA (xl(19, k_loop), k_loop=1,kx) /5.00e-11, 5.00e-11, 5.00e-11, &
&       5.00e-11, 5.00e-11, 5.00e-11, 5.00e-11, 5.00e-11, 5.00e-11, &
&       5.00e-11, 5.00e-11, 5.00e-11, 5.00e-11, 5.00e-11, 5.00e-11, &
&       5.00e-11/
  DATA (xl(18, k_loop), k_loop=1,kx) /3.61e-13, 3.61e-13, 3.61e-13, &
&       3.61e-13, 3.61e-13, 3.58e-13, 5.22e-13, 1.75e-12, 2.59e-12, &
&       2.62e-12, 2.64e-12, 2.66e-12, 2.65e-12, 2.62e-12, 2.60e-12, &
&       2.57e-12/
  DATA (xl(17, k_loop), k_loop=1,kx) /1.43e-12, 1.43e-12, 1.43e-12, &
&       1.43e-12, 1.43e-12, 1.50e-12, 2.64e-12, 8.90e-12, 1.29e-11, &
&       1.30e-11, 1.32e-11, 1.32e-11, 1.31e-11, 1.30e-11, 1.29e-11, &
&       1.27e-11/
  DATA (xl(16, k_loop), k_loop=1,kx) /1.23e-11, 1.23e-11, 1.23e-11, &
&       1.23e-11, 1.23e-11, 1.20e-11, 9.43e-12, 3.97e-12, 1.19e-12, &
&       1.11e-12, 9.93e-13, 8.66e-13, 7.78e-13, 7.26e-13, 7.04e-13, &
&       6.88e-13/
  DATA (xl(15, k_loop), k_loop=1,kx) /1.00e-20, 1.00e-20, 6.18e-20, &
&       4.18e-18, 1.23e-16, 2.13e-15, 2.50e-14, 2.21e-13, 1.30e-12, &
&       4.66e-12, 1.21e-11, 2.54e-11, 4.47e-11, 6.63e-11, 8.37e-11, &
&       9.76e-11/
  DATA (xl(14, k_loop), k_loop=1,kx) /1.15e-16, 1.15e-16, 2.46e-15, &
&       2.30e-14, 1.38e-13, 6.25e-13, 2.31e-12, 7.32e-12, 1.87e-11, &
&       3.68e-11, 6.10e-11, 9.05e-11, 1.22e-10, 1.50e-10, 1.70e-10, &
&       1.85e-10/
  DATA (xl(13, k_loop), k_loop=1,kx) /1.26e-11, 1.26e-11, 2.02e-11, &
&       2.50e-11, 3.02e-11, 4.28e-11, 6.62e-11, 1.08e-10, 1.54e-10, &
&       2.15e-10, 2.67e-10, 3.24e-10, 3.67e-10, 3.97e-10, 4.16e-10, &
&       4.31e-10/
  DATA (xl(12, k_loop), k_loop=1,kx) /1.00e-10, 1.00e-10, 1.00e-10, &
&       1.00e-10, 1.00e-10, 1.00e-10, 1.00e-10, 1.00e-10, 1.00e-10, &
&       1.00e-10, 1.00e-10, 1.00e-10, 1.00e-10, 1.00e-10, 1.00e-10, &
&       1.00e-10/
  DATA (xl(11, k_loop), k_loop=1,kx) /1.15e-16, 1.15e-16, 2.46e-15, &
&       2.30e-14, 1.38e-13, 6.25e-13, 2.31e-12, 7.32e-12, 1.87e-11, &
&       3.68e-11, 6.10e-11, 9.05e-11, 1.22e-10, 1.50e-10, 1.70e-10, &
&       1.85e-10/
  DATA (xl(10, k_loop), k_loop=1,kx) /4.00e-11, 4.00e-11, 4.00e-11, &
&       3.27e-11, 2.51e-11, 2.61e-11, 2.20e-11, 1.69e-11, 1.60e-11, &
&       1.47e-11, 1.37e-11, 1.30e-11, 1.24e-11, 1.20e-11, 1.18e-11, &
&       1.17e-11/
  DATA (xl(9, k_loop), k_loop=1,kx) /7.10e-12, 7.10e-12, 7.10e-12, &
&       7.10e-12, 7.10e-12, 7.36e-12, 1.02e-11, 2.03e-11, 2.98e-11, &
&       3.01e-11, 3.05e-11, 3.08e-11, 3.08e-11, 3.06e-11, 3.03e-11, &
&       2.99e-11/
  DATA (xl(8, k_loop), k_loop=1,kx) /9.17e-11, 9.17e-11, 9.17e-11, &
&       9.17e-11, 9.17e-11, 1.03e-10, 1.55e-10, 2.68e-10, 4.47e-10, &
&       4.59e-10, 4.72e-10, 4.91e-10, 5.05e-10, 5.13e-10, 5.14e-10, &
&       5.11e-10/
  DATA (xl(7, k_loop), k_loop=1,kx) /8.33e-29, 8.33e-29, 8.33e-29, &
&       8.33e-29, 8.33e-29, 1.33e-28, 3.54e-28, 1.85e-28, 1.29e-29, &
&       1.03e-30, 1.72e-31, 7.56e-32, 1.22e-31, 2.14e-31, 2.76e-31, &
&       2.88e-31/
!  CO is 70 ppbv at top, 80 throughout troposphere
  DATA (xl(6, k_loop), k_loop=1,kx) /7.00e-08, kxm1*8.00e-08/
  DATA (xl(5, k_loop), k_loop=1,kx) /4.16e-10, 4.16e-10, 4.16e-10, &
&       4.16e-10, 4.16e-10, 4.46e-10, 5.57e-10, 1.11e-09, 1.63e-09, &
&       1.63e-09, 1.63e-09, 1.63e-09, 1.61e-09, 1.59e-09, 1.57e-09, &
&       1.54e-09/
  DATA (xl(4, k_loop), k_loop=1,kx) /8.15e-10, 8.15e-10, 8.15e-10, &
&       8.15e-10, 8.15e-10, 8.65e-10, 1.07e-09, 1.35e-09, 1.47e-09, &
&       1.47e-09, 1.47e-09, 1.47e-09, 1.45e-09, 1.43e-09, 1.40e-09, &
&       1.38e-09/
  DATA (xl(3, k_loop), k_loop=1,kx) /9.84e-10, 9.84e-10, 5.66e-10, &
&       4.24e-10, 3.26e-10, 2.06e-10, 1.12e-10, 7.33e-11, 7.03e-11, &
&       7.52e-11, 7.96e-11, 7.56e-11, 7.27e-11, 7.07e-11, 7.00e-11, &
&       7.00e-11/
  DATA (xl(2, k_loop), k_loop=1,kx) /4.06e-10, 4.06e-10, 2.16e-10, &
&       1.37e-10, 9.47e-11, 6.95e-11, 5.31e-11, 4.19e-11, 3.46e-11, &
&       3.01e-11, 2.71e-11, 2.50e-11, 2.35e-11, 2.26e-11, 2.20e-11, &
&       2.16e-11/
!wig: To match the xl profile to the correct species, match WRF's p_<species>
!     flag with iref(p_<species>-1) to get the value of the first index in xl,
!     e.g. p_o3=6, iref(6-1)=1, so xl(1,:) is the ozone profile.
!     See gasprofile_init_pnnl for an explination of what height
!     each index represents.
  DATA (xl(1, k_loop), k_loop=1,kx) /1.68e-07, 1.68e-07, 5.79e-08, &
&       5.24e-08, 5.26e-08, 5.16e-08, 4.83e-08, 4.50e-08, 4.16e-08, &
&       3.80e-08, 3.56e-08, 3.35e-08, 3.15e-08, 3.08e-08, 3.06e-08, &
&       3.00e-08/
!     Profile heights in meters
  DATA zfa /0., 85., 212., 385., 603., 960., 1430., 2010., 2850., 4010.&
&       , 5340., 6900., 8510., 10200., 12100., 16000., 21000./
  DATA zfa_bdy /0., 85., 212., 385., 603., 960., 1430., 2010., 2850., &
&       4010., 5340., 6900., 8510., 10200., 12100., 16000., 21000./
  DATA dens /2.738e+18, 5.220e+18, 7.427e+18, 9.202e+18, 1.109e+19, &
&       1.313e+19, 1.525e+19, 1.736e+19, 1.926e+19, 2.074e+19, 2.188e+19&
&       , 2.279e+19, 2.342e+19, 2.384e+19, 2.414e+19, 2.434e+19/
  DATA so4vaptoaer /.999/

CONTAINS
!  Differentiation of flow_dep_bdy_chem in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: chem
!   with respect to varying inputs: p t chem_bxe z chem_bxs chem_btxe
!                chem_bye chem_btxs chem_bys chem_btye alt chem_btys
!                chem
!   RW status of diff variables: p:out t:out chem_bxe:out z:out
!                chem_bxs:out chem_btxe:out chem_bye:out chem_btxs:out
!                chem_bys:out chem_btye:out alt:out chem_btys:out
!                chem:in-out
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE A_FLOW_DEP_BDY_CHEM(chem, a_chem, chem_bxs, a_chem_bxs, &
&    chem_btxs, a_chem_btxs, chem_bxe, a_chem_bxe, chem_btxe, a_chem_btxe&
&    , chem_bys, a_chem_bys, chem_btys, a_chem_btys, chem_bye, a_chem_bye&
&    , chem_btye, a_chem_btye, dt, spec_bdy_width, z, a_z, have_bcs_chem&
&    , u, v, config_flags, alt, a_alt, t, a_t, pb, p, a_p, t0, p1000mb, &
&    rcp, ph, phb, g, spec_zone, ic, ids, ide, jds, jde, kds, kde, ims, &
&    ime, jms, jme, kms, kme, ips, ipe, jps, jpe, kps, kpe, its, ite, jts&
&    , jte, kts, kte)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde
    INTEGER, INTENT(IN) :: ims, ime, jms, jme, kms, kme
    INTEGER, INTENT(IN) :: ips, ipe, jps, jpe, kps, kpe
    INTEGER, INTENT(IN) :: its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: spec_zone, spec_bdy_width, ic
    REAL, INTENT(IN) :: dt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: a_chem
    REAL, DIMENSION(jms:jme, kds:kde, spec_bdy_width), INTENT(IN) :: &
&    chem_bxs, chem_bxe, chem_btxs, chem_btxe
    REAL, DIMENSION(jms:jme, kds:kde, spec_bdy_width) :: a_chem_bxs, &
&    a_chem_bxe, a_chem_btxs, a_chem_btxe
    REAL, DIMENSION(ims:ime, kds:kde, spec_bdy_width), INTENT(IN) :: &
&    chem_bys, chem_bye, chem_btys, chem_btye
    REAL, DIMENSION(ims:ime, kds:kde, spec_bdy_width) :: a_chem_bys, &
&    a_chem_bye, a_chem_btys, a_chem_btye
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: z
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_z
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: alt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_alt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: v
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: ph, phb, t&
&    , pb, p
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_t, a_p
    REAL, INTENT(IN) :: g, rcp, t0, p1000mb
    TYPE(GRID_CONFIG_REC_TYPE) :: config_flags
    INTEGER :: i, j, k, numgas
    INTEGER :: ibs, ibe, jbs, jbe, itf, jtf, ktf
    INTEGER :: i_inner, j_inner
    INTEGER :: b_dist
    INTEGER :: itestbc, i_bdy_method
    REAL :: tempfac, convfac
    REAL :: a_tempfac, a_convfac
    REAL :: chem_bv_def
    LOGICAL :: have_bcs_chem
    REAL :: tmp
    REAL :: tmp0
    REAL :: tmp1
    REAL :: tmp2
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    INTEGER :: min6
    INTEGER :: min5
    INTEGER :: min4
    REAL :: temp1b
    INTEGER :: min3
    INTEGER :: min2
    INTEGER :: min7
    REAL :: tmp0b
    REAL :: temp3b
    REAL :: tmp1b
    REAL :: tmp2b
    REAL :: temp5b
    REAL :: temp7b
    INTEGER :: max6
    INTEGER :: max5
    INTEGER :: max4
    REAL :: temp
    INTEGER :: max3
    INTEGER :: max2
    INTEGER :: max7
    REAL :: temp6
    REAL :: temp5
    REAL :: tmpb
    REAL :: temp4
    numgas = GET_LAST_GAS(config_flags%chem_opt)
    ibs = ids
    ibe = ide - 1
    IF (ite .GT. ide - 1) THEN
      itf = ide - 1
    ELSE
      itf = ite
    END IF
    jbs = jds
    jbe = jde - 1
    IF (jte .GT. jde - 1) THEN
      jtf = jde - 1
    ELSE
      jtf = jte
    END IF
    ktf = kde - 1
! i_bdy_method determines which "bdy_chem_value" routine to use
!   1=radm2 or racm gas for  p_so2     <= ic <= p_ho2
!   2=sorgam aerosol    for  p_so4aj   <= ic <= p_corn
!   3=cbmz gas          for  p_hcl     <= ic <= p_isopo2
!                        OR  p_dms     <= ic <= p_mtf
!   4=mosaic aerosol    for  p_so4_a01 <= ic <= p_num_a01
!                        OR  p_so4_a02 <= ic <= p_num_a02
!                        OR  ...
!   5=tracer mode
!   0=none              for all other ic values
! (note:  some cbmz packages use dms,...,mtf while others do not)
! (note:  different mosaic packages use different number of sections)
    i_bdy_method = 0
    IF (ic .GE. p_so2 .AND. ic .LE. p_ho2) THEN
      i_bdy_method = 1
      IF (((((config_flags%chem_opt .EQ. racm_kpp .OR. config_flags%&
&          chem_opt .EQ. gocartracm_kpp) .OR. config_flags%chem_opt .EQ. &
&          racmsorg_kpp) .OR. config_flags%chem_opt .EQ. &
&          racm_esrlsorg_kpp) .OR. config_flags%chem_opt .EQ. &
&          racm_soa_vbs_kpp) .OR. config_flags%chem_opt .EQ. racm_mim_kpp&
&      ) i_bdy_method = 9
      IF (config_flags%chem_opt .EQ. racmpm_kpp) i_bdy_method = 9
    ELSE IF (ic .GE. p_so4aj .AND. ic .LE. p_corn) THEN
      i_bdy_method = 2
    ELSE IF (ic .GE. p_hcl .AND. ic .LE. p_isopo2) THEN
      i_bdy_method = 3
    ELSE IF (ic .GE. p_dms .AND. ic .LE. p_mtf) THEN
      i_bdy_method = 3
    ELSE IF (ic .GE. p_so4_a01 .AND. ic .LE. p_num_a01) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a02 .AND. ic .LE. p_num_a02) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a03 .AND. ic .LE. p_num_a03) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a04 .AND. ic .LE. p_num_a04) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a05 .AND. ic .LE. p_num_a05) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a06 .AND. ic .LE. p_num_a06) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a07 .AND. ic .LE. p_num_a07) THEN
      i_bdy_method = 4
    ELSE IF (ic .GE. p_so4_a08 .AND. ic .LE. p_num_a08) THEN
      i_bdy_method = 4
    ELSE IF (config_flags%chem_opt .EQ. chem_tracer) THEN
      i_bdy_method = 5
    ELSE IF (config_flags%chem_opt .EQ. chem_trace2) THEN
      i_bdy_method = 5
    ELSE IF (config_flags%chem_opt .EQ. gocart_simple &
      .or. config_flags%chem_opt .EQ. gocart_bcco &
      .or. config_flags%chem_opt .EQ. gocart_bc &
     ) THEN
      i_bdy_method = 7
    ELSE IF (config_flags%chem_opt .EQ. dust) THEN
      i_bdy_method = 7
    ELSE IF (config_flags%chem_opt .EQ. chem_vash) THEN
      i_bdy_method = 8
    ELSE IF (config_flags%chem_opt .EQ. chem_volc) THEN
      i_bdy_method = 8
    ELSE IF (config_flags%chem_opt .EQ. chem_volc_4bin) THEN
      i_bdy_method = 8
    ELSE IF (config_flags%chem_opt .EQ. co2_tracer .OR. config_flags%&
&        chem_opt .EQ. ghg_tracer) THEN
      i_bdy_method = 16
!         CALL wrf_message( "For GHGs strongly recommended to include LBCs from a global model!" )
    ELSE IF (config_flags%chem_opt .EQ. cbmz_cam_mam3_noaq .OR. &
&        config_flags%chem_opt .EQ. cbmz_cam_mam3_aq) THEN
      IF (ic .GE. p_so4_a1 .AND. ic .LE. p_num_a3) i_bdy_method = 501
    ELSE IF (config_flags%chem_opt .EQ. cbmz_cam_mam7_noaq .OR. &
&        config_flags%chem_opt .EQ. cbmz_cam_mam7_aq) THEN
      IF (ic .GE. p_so4_a1 .AND. ic .LE. p_num_a7) i_bdy_method = 501
    END IF
    IF (have_bcs_chem) i_bdy_method = 6
    IF (ic .LT. param_first_scalar) i_bdy_method = 0
!
    IF (jts - jbs .LT. spec_zone) THEN
      IF (jtf .GT. jbs + spec_zone - 1) THEN
        min7 = jbs + spec_zone - 1
      ELSE
        min7 = jtf
      END IF
! Y-start boundary
      DO j=jts,min7
        b_dist = j - jbs
        DO k=kts,ktf
          IF (its .LT. b_dist + ibs) THEN
            max7 = b_dist + ibs
          ELSE
            max7 = its
          END IF
          IF (itf .GT. ibe - b_dist) THEN
            min3 = ibe - b_dist
          ELSE
            min3 = itf
          END IF
          ad_from = max7
          DO i=ad_from,min3
            IF (i .LT. ibs + spec_zone) THEN
              CALL PUSHINTEGER4(i_inner)
              i_inner = ibs + spec_zone
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(i_inner)
              i_inner = i
              CALL PUSHCONTROL1B(1)
            END IF
            IF (i_inner .GT. ibe - spec_zone) THEN
              i_inner = ibe - spec_zone
            ELSE
              i_inner = i_inner
            END IF
            IF (v(i, k, j) .LT. 0.) THEN
              CALL PUSHCONTROL4B(9)
            ELSE IF (i_bdy_method .EQ. 1) THEN
              CALL PUSHCONTROL4B(8)
            ELSE IF (i_bdy_method .EQ. 9) THEN
              CALL PUSHCONTROL4B(7)
            ELSE IF (i_bdy_method .EQ. 2) THEN
              CALL PUSHREAL8(tempfac)
              tempfac = (t(i, k, j)+t0)*((p(i, k, j)+pb(i, k, j))/&
&                p1000mb)**rcp
              convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!              CALL PUSHREAL8(esc36)
!              CALL PUSHREAL8(esa36)
!              CALL PUSHREAL8(esn36)
              CALL BDY_CHEM_VALUE_SORGAM(chem(i, k, j), z(i, k, j), ic, &
&                                   config_flags, alt(i, k, j), convfac, &
&                                   g)
!                else if (i_bdy_method .eq. 3) then
!                   CALL bdy_chem_value_cbmz (   &
!                        chem(i,k,j), z(i,k,j), ic, numgas )
!                else if (i_bdy_method .eq. 4) then
!                   CALL bdy_chem_value_mosaic (   &
!                        chem(i,k,j), alt(i,k,j), z(i,k,j), ic, config_flags )
              CALL PUSHCONTROL4B(6)
            ELSE IF (i_bdy_method .EQ. 5) THEN
              CALL PUSHCONTROL4B(5)
            ELSE IF (i_bdy_method .EQ. 7) THEN
              CALL PUSHCONTROL4B(4)
            ELSE IF (i_bdy_method .EQ. 8) THEN
              CALL PUSHCONTROL4B(3)
            ELSE IF (i_bdy_method .EQ. 6) THEN
              CALL PUSHCONTROL4B(2)
            ELSE IF (i_bdy_method .EQ. 16) THEN
              CALL PUSHCONTROL4B(1)
            ELSE
              CALL PUSHCONTROL4B(0)
            END IF
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from)
        END DO
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (jbe - jtf .LT. spec_zone) THEN
      IF (jts .LT. jbe - spec_zone + 1) THEN
        max2 = jbe - spec_zone + 1
      ELSE
        max2 = jts
      END IF
! Y-end boundary 
      DO j=max2,jtf
        b_dist = jbe - j
        DO k=kts,ktf
          IF (its .LT. b_dist + ibs) THEN
            max3 = b_dist + ibs
          ELSE
            max3 = its
          END IF
          IF (itf .GT. ibe - b_dist) THEN
            min4 = ibe - b_dist
          ELSE
            min4 = itf
          END IF
          ad_from0 = max3
          DO i=ad_from0,min4
            IF (i .LT. ibs + spec_zone) THEN
              CALL PUSHINTEGER4(i_inner)
              i_inner = ibs + spec_zone
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(i_inner)
              i_inner = i
              CALL PUSHCONTROL1B(1)
            END IF
            IF (i_inner .GT. ibe - spec_zone) THEN
              i_inner = ibe - spec_zone
            ELSE
              i_inner = i_inner
            END IF
            IF (v(i, k, j+1) .GT. 0.) THEN
              CALL PUSHCONTROL4B(9)
            ELSE IF (i_bdy_method .EQ. 1) THEN
              CALL PUSHCONTROL4B(8)
            ELSE IF (i_bdy_method .EQ. 9) THEN
              CALL PUSHCONTROL4B(7)
            ELSE IF (i_bdy_method .EQ. 2) THEN
              CALL PUSHREAL8(tempfac)
              tempfac = (t(i, k, j)+t0)*((p(i, k, j)+pb(i, k, j))/&
&                p1000mb)**rcp
              convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!              CALL PUSHREAL8(esc36)
!              CALL PUSHREAL8(esa36)
!              CALL PUSHREAL8(esn36)
              CALL BDY_CHEM_VALUE_SORGAM(chem(i, k, j), z(i, k, j), ic, &
&                                   config_flags, alt(i, k, j), convfac, &
&                                   g)
!                else if (i_bdy_method .eq. 3) then
!                   CALL bdy_chem_value_cbmz (   &
!                        chem(i,k,j), z(i,k,j), ic, numgas )
!                else if (i_bdy_method .eq. 4) then
!                   CALL bdy_chem_value_mosaic (   &
!                        chem(i,k,j), alt(i,k,j), z(i,k,j), ic, config_flags )
              CALL PUSHCONTROL4B(6)
            ELSE IF (i_bdy_method .EQ. 5) THEN
              CALL PUSHCONTROL4B(5)
            ELSE IF (i_bdy_method .EQ. 6) THEN
              CALL PUSHCONTROL4B(4)
            ELSE IF (i_bdy_method .EQ. 7) THEN
              CALL PUSHCONTROL4B(3)
            ELSE IF (i_bdy_method .EQ. 8) THEN
              CALL PUSHCONTROL4B(2)
            ELSE IF (i_bdy_method .EQ. 16) THEN
              CALL PUSHCONTROL4B(1)
            ELSE
              CALL PUSHCONTROL4B(0)
            END IF
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from0)
        END DO
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (its - ibs .LT. spec_zone) THEN
      IF (itf .GT. ibs + spec_zone - 1) THEN
        min2 = ibs + spec_zone - 1
      ELSE
        min2 = itf
      END IF
! X-start boundary
      DO i=its,min2
        b_dist = i - ibs
        DO k=kts,ktf
          IF (jts .LT. b_dist + jbs + 1) THEN
            max4 = b_dist + jbs + 1
          ELSE
            max4 = jts
          END IF
          IF (jtf .GT. jbe - b_dist - 1) THEN
            min5 = jbe - b_dist - 1
          ELSE
            min5 = jtf
          END IF
          ad_from1 = max4
          DO j=ad_from1,min5
            IF (j .LT. jbs + spec_zone) THEN
              CALL PUSHINTEGER4(j_inner)
              j_inner = jbs + spec_zone
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(j_inner)
              j_inner = j
              CALL PUSHCONTROL1B(1)
            END IF
            IF (j_inner .GT. jbe - spec_zone) THEN
              j_inner = jbe - spec_zone
            ELSE
              j_inner = j_inner
            END IF
            IF (u(i, k, j) .LT. 0.) THEN
              CALL PUSHCONTROL4B(9)
            ELSE IF (i_bdy_method .EQ. 1) THEN
              CALL PUSHCONTROL4B(8)
            ELSE IF (i_bdy_method .EQ. 9) THEN
              CALL PUSHCONTROL4B(7)
            ELSE IF (i_bdy_method .EQ. 2) THEN
              CALL PUSHREAL8(tempfac)
              tempfac = (t(i, k, j)+t0)*((p(i, k, j)+pb(i, k, j))/&
&                p1000mb)**rcp
              convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!              CALL PUSHREAL8(esc36)
!              CALL PUSHREAL8(esa36)
!              CALL PUSHREAL8(esn36)
              CALL BDY_CHEM_VALUE_SORGAM(chem(i, k, j), z(i, k, j), ic, &
&                                   config_flags, alt(i, k, j), convfac, &
&                                   g)
!                else if (i_bdy_method .eq. 3) then
!                   CALL bdy_chem_value_cbmz (   &
!                        chem(i,k,j), z(i,k,j), ic, numgas )
!                else if (i_bdy_method .eq. 4) then
!                   CALL bdy_chem_value_mosaic (   &
!                        chem(i,k,j), alt(i,k,j), z(i,k,j), ic, config_flags )
              CALL PUSHCONTROL4B(6)
            ELSE IF (i_bdy_method .EQ. 5) THEN
              CALL PUSHCONTROL4B(5)
            ELSE IF (i_bdy_method .EQ. 6) THEN
              CALL PUSHCONTROL4B(4)
            ELSE IF (i_bdy_method .EQ. 7) THEN
              CALL PUSHCONTROL4B(3)
            ELSE IF (i_bdy_method .EQ. 8) THEN
              CALL PUSHCONTROL4B(2)
            ELSE IF (i_bdy_method .EQ. 16) THEN
              CALL PUSHCONTROL4B(1)
            ELSE
              CALL PUSHCONTROL4B(0)
            END IF
          END DO
          CALL PUSHINTEGER4(j - 1)
          CALL PUSHINTEGER4(ad_from1)
        END DO
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (ibe - itf .LT. spec_zone) THEN
      IF (its .LT. ibe - spec_zone + 1) THEN
        max5 = ibe - spec_zone + 1
      ELSE
        max5 = its
      END IF
! X-end boundary
      DO i=max5,itf
        b_dist = ibe - i
        DO k=kts,ktf
          IF (jts .LT. b_dist + jbs + 1) THEN
            max6 = b_dist + jbs + 1
          ELSE
            max6 = jts
          END IF
          IF (jtf .GT. jbe - b_dist - 1) THEN
            min6 = jbe - b_dist - 1
          ELSE
            min6 = jtf
          END IF
          ad_from2 = max6
          DO j=ad_from2,min6
            IF (j .LT. jbs + spec_zone) THEN
              CALL PUSHINTEGER4(j_inner)
              j_inner = jbs + spec_zone
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(j_inner)
              j_inner = j
              CALL PUSHCONTROL1B(1)
            END IF
            IF (j_inner .GT. jbe - spec_zone) THEN
              j_inner = jbe - spec_zone
            ELSE
              j_inner = j_inner
            END IF
            IF (u(i+1, k, j) .GT. 0.) THEN
              CALL PUSHCONTROL4B(9)
            ELSE IF (i_bdy_method .EQ. 1) THEN
              CALL PUSHCONTROL4B(8)
            ELSE IF (i_bdy_method .EQ. 9) THEN
              CALL PUSHCONTROL4B(7)
            ELSE IF (i_bdy_method .EQ. 2) THEN
              CALL PUSHREAL8(tempfac)
              tempfac = (t(i, k, j)+t0)*((p(i, k, j)+pb(i, k, j))/&
&                p1000mb)**rcp
              convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!              CALL PUSHREAL8(esc36)
!              CALL PUSHREAL8(esa36)
!              CALL PUSHREAL8(esn36)
              CALL BDY_CHEM_VALUE_SORGAM(chem(i, k, j), z(i, k, j), ic, &
&                                   config_flags, alt(i, k, j), convfac, &
&                                   g)
!                else if (i_bdy_method .eq. 3) then
!                   CALL bdy_chem_value_cbmz (   &
!                        chem(i,k,j), z(i,k,j), ic, numgas )
!                else if (i_bdy_method .eq. 4) then
!                   CALL bdy_chem_value_mosaic (   &
!                        chem(i,k,j), alt(i,k,j), z(i,k,j), ic, config_flags )
              CALL PUSHCONTROL4B(6)
            ELSE IF (i_bdy_method .EQ. 5) THEN
              CALL PUSHCONTROL4B(5)
            ELSE IF (i_bdy_method .EQ. 6) THEN
              CALL PUSHCONTROL4B(4)
            ELSE IF (i_bdy_method .EQ. 7) THEN
              CALL PUSHCONTROL4B(3)
            ELSE IF (i_bdy_method .EQ. 8) THEN
              CALL PUSHCONTROL4B(2)
            ELSE IF (i_bdy_method .EQ. 16) THEN
              CALL PUSHCONTROL4B(1)
            ELSE
              CALL PUSHCONTROL4B(0)
            END IF
          END DO
          CALL PUSHINTEGER4(j - 1)
          CALL PUSHINTEGER4(ad_from2)
        END DO
      END DO
!      a_p = 0.0_8
!      a_t = 0.0_8
!      a_chem_bxe = 0.0_8
!      a_z = 0.0_8
!      a_chem_btxe = 0.0_8
!      a_alt = 0.0_8
      DO i=itf,max5,-1
        DO k=ktf,kts,-1
          CALL POPINTEGER4(ad_from2)
          CALL POPINTEGER4(ad_to2)
          DO j=ad_to2,ad_from2,-1
            CALL POPCONTROL4B(branch)
            IF (branch .LT. 5) THEN
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .EQ. 2) THEN
                a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .NE. 3) THEN
                CALL A_BDY_CHEM_VALUE_GCM(chem(i, k, j), a_chem(i, k, j)&
&                                    , chem_bxe(j, k, 1), a_chem_bxe(j, k&
&                                    , 1), chem_btxe(j, k, 1), &
&                                    a_chem_btxe(j, k, 1), dt, ic)
                a_chem(i, k, j) = 0.0_8
              END IF
            ELSE IF (branch .LT. 7) THEN
              IF (branch .NE. 5) THEN
                temp6 = pb(i, k, j) + p(i, k, j)
                temp5 = temp6/p1000mb
                convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!                CALL POPREAL8(esn36)
!                CALL POPREAL8(esa36)
!                CALL POPREAL8(esc36)
                CALL A_BDY_CHEM_VALUE_SORGAM(chem(i, k, j), a_chem(i, k&
&                                       , j), z(i, k, j), a_z(i, k, j), &
&                                       ic, config_flags, alt(i, k, j), &
&                                       a_alt(i, k, j), convfac, &
&                                       a_convfac, g)
                temp7b = a_convfac/(rgasuniv*tempfac)
                a_tempfac = -((pb(i, k, j)+p(i, k, j))*temp7b/tempfac)
                IF (temp5 .LE. 0.0_8 .AND. (rcp .EQ. 0.0_8 .OR. rcp .NE.&
&                    INT(rcp))) THEN
                  a_p(i, k, j) = a_p(i, k, j) + temp7b
                ELSE
                  a_p(i, k, j) = a_p(i, k, j) + rcp*temp5**(rcp-1)*(t0+t&
&                    (i, k, j))*a_tempfac/p1000mb + temp7b
                END IF
                CALL POPREAL8(tempfac)
                a_t(i, k, j) = a_t(i, k, j) + temp5**rcp*a_tempfac
              END IF
            ELSE IF (branch .EQ. 7) THEN
              CALL A_BDY_CHEM_VALUE_RACM(chem(i, k, j), a_chem(i, k, j)&
&                                   , z(i, k, j), a_z(i, k, j), ic, &
&                                   numgas, p_co2)
            ELSE IF (branch .EQ. 8) THEN
              CALL A_BDY_CHEM_VALUE(chem(i, k, j), a_chem(i, k, j), z(i&
&                              , k, j), a_z(i, k, j), ic, numgas)
              a_chem(i, k, j) = 0.0_8
            ELSE
              tmp2b = a_chem(i, k, j)
              a_chem(i, k, j) = 0.0_8
              a_chem(ibe-spec_zone, k, j_inner) = a_chem(ibe-spec_zone, &
&                k, j_inner) + tmp2b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPINTEGER4(j_inner)
            ELSE
              CALL POPINTEGER4(j_inner)
            END IF
          END DO
        END DO
      END DO
!    ELSE
!      a_p = 0.0_8
!      a_t = 0.0_8
!      a_chem_bxe = 0.0_8
!      a_z = 0.0_8
!      a_chem_btxe = 0.0_8
!      a_alt = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
!      a_chem_bxs = 0.0_8
!      a_chem_btxs = 0.0_8
      DO i=min2,its,-1
        DO k=ktf,kts,-1
          CALL POPINTEGER4(ad_from1)
          CALL POPINTEGER4(ad_to1)
          DO j=ad_to1,ad_from1,-1
            CALL POPCONTROL4B(branch)
            IF (branch .LT. 5) THEN
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .EQ. 2) THEN
                a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .NE. 3) THEN
                CALL A_BDY_CHEM_VALUE_GCM(chem(i, k, j), a_chem(i, k, j)&
&                                    , chem_bxs(j, k, 1), a_chem_bxs(j, k&
&                                    , 1), chem_btxs(j, k, 1), &
&                                    a_chem_btxs(j, k, 1), dt, ic)
                a_chem(i, k, j) = 0.0_8
              END IF
            ELSE IF (branch .LT. 7) THEN
              IF (branch .NE. 5) THEN
                temp4 = pb(i, k, j) + p(i, k, j)
                temp3 = temp4/p1000mb
                convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!                CALL POPREAL8(esn36)
!                CALL POPREAL8(esa36)
!                CALL POPREAL8(esc36)
                CALL A_BDY_CHEM_VALUE_SORGAM(chem(i, k, j), a_chem(i, k&
&                                       , j), z(i, k, j), a_z(i, k, j), &
&                                       ic, config_flags, alt(i, k, j), &
&                                       a_alt(i, k, j), convfac, &
&                                       a_convfac, g)
                temp5b = a_convfac/(rgasuniv*tempfac)
                a_tempfac = -((pb(i, k, j)+p(i, k, j))*temp5b/tempfac)
                IF (temp3 .LE. 0.0_8 .AND. (rcp .EQ. 0.0_8 .OR. rcp .NE.&
&                    INT(rcp))) THEN
                  a_p(i, k, j) = a_p(i, k, j) + temp5b
                ELSE
                  a_p(i, k, j) = a_p(i, k, j) + rcp*temp3**(rcp-1)*(t0+t&
&                    (i, k, j))*a_tempfac/p1000mb + temp5b
                END IF
                CALL POPREAL8(tempfac)
                a_t(i, k, j) = a_t(i, k, j) + temp3**rcp*a_tempfac
              END IF
            ELSE IF (branch .EQ. 7) THEN
              CALL A_BDY_CHEM_VALUE_RACM(chem(i, k, j), a_chem(i, k, j)&
&                                   , z(i, k, j), a_z(i, k, j), ic, &
&                                   numgas, p_co2)
            ELSE IF (branch .EQ. 8) THEN
              CALL A_BDY_CHEM_VALUE(chem(i, k, j), a_chem(i, k, j), z(i&
&                              , k, j), a_z(i, k, j), ic, numgas)
              a_chem(i, k, j) = 0.0_8
            ELSE
              tmp1b = a_chem(i, k, j)
              a_chem(i, k, j) = 0.0_8
              a_chem(ibs+spec_zone, k, j_inner) = a_chem(ibs+spec_zone, &
&                k, j_inner) + tmp1b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPINTEGER4(j_inner)
            ELSE
              CALL POPINTEGER4(j_inner)
            END IF
          END DO
        END DO
      END DO
!    ELSE
!      a_chem_bxs = 0.0_8
!      a_chem_btxs = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
!      a_chem_bye = 0.0_8
!      a_chem_btye = 0.0_8
      DO j=jtf,max2,-1
        DO k=ktf,kts,-1
          CALL POPINTEGER4(ad_from0)
          CALL POPINTEGER4(ad_to0)
          DO i=ad_to0,ad_from0,-1
            CALL POPCONTROL4B(branch)
            IF (branch .LT. 5) THEN
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .EQ. 2) THEN
                a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .NE. 3) THEN
                CALL A_BDY_CHEM_VALUE_GCM(chem(i, k, j), a_chem(i, k, j)&
&                                    , chem_bye(i, k, 1), a_chem_bye(i, k&
&                                    , 1), chem_btye(i, k, 1), &
&                                    a_chem_btye(i, k, 1), dt, ic)
                a_chem(i, k, j) = 0.0_8
              END IF
            ELSE IF (branch .LT. 7) THEN
              IF (branch .NE. 5) THEN
                temp2 = pb(i, k, j) + p(i, k, j)
                temp1 = temp2/p1000mb
                convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!                CALL POPREAL8(esn36)
!                CALL POPREAL8(esa36)
!                CALL POPREAL8(esc36)
                CALL A_BDY_CHEM_VALUE_SORGAM(chem(i, k, j), a_chem(i, k&
&                                       , j), z(i, k, j), a_z(i, k, j), &
&                                       ic, config_flags, alt(i, k, j), &
&                                       a_alt(i, k, j), convfac, &
&                                       a_convfac, g)
                temp3b = a_convfac/(rgasuniv*tempfac)
                a_tempfac = -((pb(i, k, j)+p(i, k, j))*temp3b/tempfac)
                IF (temp1 .LE. 0.0_8 .AND. (rcp .EQ. 0.0_8 .OR. rcp .NE.&
&                    INT(rcp))) THEN
                  a_p(i, k, j) = a_p(i, k, j) + temp3b
                ELSE
                  a_p(i, k, j) = a_p(i, k, j) + rcp*temp1**(rcp-1)*(t0+t&
&                    (i, k, j))*a_tempfac/p1000mb + temp3b
                END IF
                CALL POPREAL8(tempfac)
                a_t(i, k, j) = a_t(i, k, j) + temp1**rcp*a_tempfac
              END IF
            ELSE IF (branch .EQ. 7) THEN
              CALL A_BDY_CHEM_VALUE_RACM(chem(i, k, j), a_chem(i, k, j)&
&                                   , z(i, k, j), a_z(i, k, j), ic, &
&                                   numgas, p_co2)
            ELSE IF (branch .EQ. 8) THEN
              CALL A_BDY_CHEM_VALUE(chem(i, k, j), a_chem(i, k, j), z(i&
&                              , k, j), a_z(i, k, j), ic, numgas)
              a_chem(i, k, j) = 0.0_8
            ELSE
              tmp0b = a_chem(i, k, j)
              a_chem(i, k, j) = 0.0_8
              a_chem(i_inner, k, jbe-spec_zone) = a_chem(i_inner, k, jbe&
&                -spec_zone) + tmp0b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPINTEGER4(i_inner)
            ELSE
              CALL POPINTEGER4(i_inner)
            END IF
          END DO
        END DO
      END DO
!    ELSE
!      a_chem_bye = 0.0_8
!      a_chem_btye = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
!      a_chem_bys = 0.0_8
!      a_chem_btys = 0.0_8
      DO j=min7,jts,-1
        DO k=ktf,kts,-1
          CALL POPINTEGER4(ad_from)
          CALL POPINTEGER4(ad_to)
          DO i=ad_to,ad_from,-1
            CALL POPCONTROL4B(branch)
            IF (branch .LT. 5) THEN
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .EQ. 2) THEN
                CALL A_BDY_CHEM_VALUE_GCM(chem(i, k, j), a_chem(i, k, j)&
&                                    , chem_bys(i, k, 1), a_chem_bys(i, k&
&                                    , 1), chem_btys(i, k, 1), &
&                                    a_chem_btys(i, k, 1), dt, ic)
                a_chem(i, k, j) = 0.0_8
              ELSE IF (branch .EQ. 3) THEN
                a_chem(i, k, j) = 0.0_8
              END IF
            ELSE IF (branch .LT. 7) THEN
              IF (branch .NE. 5) THEN
                temp0 = pb(i, k, j) + p(i, k, j)
                temp = temp0/p1000mb
                convfac = (p(i, k, j)+pb(i, k, j))/rgasuniv/tempfac
!                CALL POPREAL8(esn36)
!                CALL POPREAL8(esa36)
!                CALL POPREAL8(esc36)
                CALL A_BDY_CHEM_VALUE_SORGAM(chem(i, k, j), a_chem(i, k&
&                                       , j), z(i, k, j), a_z(i, k, j), &
&                                       ic, config_flags, alt(i, k, j), &
&                                       a_alt(i, k, j), convfac, &
&                                       a_convfac, g)
                temp1b = a_convfac/(rgasuniv*tempfac)
                a_tempfac = -((pb(i, k, j)+p(i, k, j))*temp1b/tempfac)
                IF (temp .LE. 0.0_8 .AND. (rcp .EQ. 0.0_8 .OR. rcp .NE. &
&                    INT(rcp))) THEN
                  a_p(i, k, j) = a_p(i, k, j) + temp1b
                ELSE
                  a_p(i, k, j) = a_p(i, k, j) + rcp*temp**(rcp-1)*(t0+t(&
&                    i, k, j))*a_tempfac/p1000mb + temp1b
                END IF
                CALL POPREAL8(tempfac)
                a_t(i, k, j) = a_t(i, k, j) + temp**rcp*a_tempfac
              END IF
            ELSE IF (branch .EQ. 7) THEN
              CALL A_BDY_CHEM_VALUE_RACM(chem(i, k, j), a_chem(i, k, j)&
&                                   , z(i, k, j), a_z(i, k, j), ic, &
&                                   numgas, p_co2)
            ELSE IF (branch .EQ. 8) THEN
              CALL A_BDY_CHEM_VALUE(chem(i, k, j), a_chem(i, k, j), z(i&
&                              , k, j), a_z(i, k, j), ic, numgas)
              a_chem(i, k, j) = 0.0_8
            ELSE
              tmpb = a_chem(i, k, j)
              a_chem(i, k, j) = 0.0_8
              a_chem(i_inner, k, jbs+spec_zone) = a_chem(i_inner, k, jbs&
&                +spec_zone) + tmpb
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPINTEGER4(i_inner)
            ELSE
              CALL POPINTEGER4(i_inner)
            END IF
          END DO
        END DO
      END DO
!    ELSE
!      a_chem_bys = 0.0_8
!      a_chem_btys = 0.0_8
    END IF
  END SUBROUTINE A_FLOW_DEP_BDY_CHEM
!  Differentiation of bdy_chem_value_sorgam in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: z alt chem
!   with respect to varying inputs: z convfac alt chem
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! this is a kludge routine as of now....
!
  SUBROUTINE A_BDY_CHEM_VALUE_SORGAM(chem, a_chem, z, a_z, nch, &
&    config_flags, alt, a_alt, convfac, a_convfac, g)
    USE module_data_sorgam
    IMPLICIT NONE
    REAL :: chem
    REAL :: a_chem
! 3D height array
    REAL, INTENT(IN) :: z
    REAL :: a_z
! index number of chemical species
    INTEGER, INTENT(IN) :: nch
    REAL, INTENT(IN) :: alt, convfac
    REAL :: a_alt, a_convfac
    REAL, INTENT(IN) :: g
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    INTEGER :: i, k, l
! chemical profile, diff. index order
    REAL, DIMENSION(lo + 1, kx) :: cprof
    REAL, DIMENSION(kx) :: zprof
    REAL, DIMENSION(lo) :: stor
    REAL, DIMENSION(lo) :: a_stor
    REAL :: wgt0
    REAL :: a_wgt0
    REAL :: chemsulf_radm, chem_so4aj, chem_so4ai
    REAL :: a_chemsulf_radm, a_chem_so4aj, a_chem_so4ai
    REAL :: tempfac
    REAL :: splitfac
!between gas and aerosol phase
!factor for splitting initial conc. of SO4
!3rd moment i-mode [3rd moment/m^3]
    REAL :: m3nuc
    REAL :: a_m3nuc
!3rd MOMENT j-mode [3rd moment/m^3]
    REAL :: m3acc
    REAL :: a_m3acc
!       REAL ESN36
    REAL :: m3cor
    EXTERNAL WRF_ERROR_FATAL
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    REAL :: a_x1(2:lo+1)
    REAL :: x1(2:lo+1)
    REAL :: tempb2
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
    LOGICAL :: mask(2:lo+1)
    DATA splitfac /.98/
!
! method for bc calculation is determined by aer_bc_opt
!
    IF (config_flags%aer_bc_opt .EQ. aer_bc_pnnl) THEN
      CALL A_SORGAM_SET_AER_BC_PNNL(chem, a_chem, z, a_z, nch, &
&                              config_flags)
      a_convfac = 0.0_8
    ELSE
! do default calculation of sorgam aerosol bc values
!      tempfac=(t+t0)*((p+pb)/p1000mb)**rcp
!      convfac=(p+pb)/rgasuniv/tempfac
!
!--- units for advection....
!
      IF (nch .EQ. p_nu0) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nch .EQ. p_ac0) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nch .EQ. p_nh4aj) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nch .EQ. p_nh4ai) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nch .EQ. p_no3aj) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nch .EQ. p_no3ai) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!
! recalculate sulf profile for aerosols
!
      IF ((((nch .EQ. p_so4aj .OR. nch .EQ. p_so4ai) .OR. nch .EQ. p_nu0&
&          ) .OR. nch .EQ. p_ac0) .OR. nch .EQ. p_corn) THEN
! Vertically flip the chemistry data as it is given top down 
!     and heights in zfa are bottom up
! Fill chemical profile array cprof
! Keep chem slot 1 open as vinterp_chem assumes there is no data
!     (this isn't really needed in this subr)
! Convert species 28-34 (lo-6:lo) from (molecules/cm3) to (mol/mol)
        DO k=1,kx
          zprof(k) = 0.5*(zfa_bdy(k)+zfa_bdy(k+1))
          DO l=1,lo-7
            cprof(l+1, k) = xl(l, kx+1-k)
          END DO
! Fix number concentrations to mixing ratios for short-lived NALROM species
          DO l=lo-6,lo
            cprof(l+1, k) = xl(l, kx+1-k)/dens(kx+1-k)
          END DO
        END DO
! Interpolate temp 1D chemical profile array to WRF field
        IF (z .LT. zprof(1)) THEN
          CALL PUSHCONTROL2B(0)
          stor(1:lo) = cprof(2:lo+1, 1)
        ELSE IF (z .GE. zprof(kx)) THEN
          CALL PUSHCONTROL2B(1)
          stor(1:lo) = cprof(2:lo+1, kx)
        ELSE
          ad_count = 1
! We can trap between two levels and linearly interpolate
input_loop:DO k=1,kx-1
            IF (z .EQ. zprof(k)) THEN
              GOTO 100
            ELSE IF (z .GT. zprof(k) .AND. z .LT. zprof(k+1)) THEN
              GOTO 110
            ELSE
              ad_count = ad_count + 1
            END IF
          END DO input_loop
          CALL PUSHCONTROL2B(0)
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHCONTROL2B(2)
          GOTO 120
 100      CALL PUSHCONTROL2B(1)
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHCONTROL2B(2)
          stor(1:lo) = cprof(2:lo+1, k)
          GOTO 120
 110      CALL PUSHCONTROL2B(2)
          CALL PUSHINTEGER4(ad_count)
          wgt0 = (z-zprof(k+1))/(zprof(k)-zprof(k+1))
          x1 = wgt0*cprof(2:lo+1, k) + (1.-wgt0)*cprof(2:lo+1, k+1)
          mask = x1 .LT. 0.
          WHERE (mask) 
            stor(1:lo) = 0.
          ELSEWHERE
            stor(1:lo) = x1
          END WHERE
          CALL PUSHCONTROL2B(3)
        END IF
! Here is where the chemistry value is constructed
 120    chemsulf_radm = fracref(p_sulf-1)*stor(iref(p_sulf-1))*1.e6
!
! now have sulf
!
        chem_so4aj = chemsulf_radm*convfac*mwso4*splitfac*so4vaptoaer
        chem_so4ai = chemsulf_radm*convfac*mwso4*(1.-splitfac)*&
&          so4vaptoaer
        IF (nch .EQ. p_so4aj) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (nch .EQ. p_so4ai) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        m3nuc = so4fac*chem_so4ai + conmin*(nh4fac+no3fac+orgfac*9+2*&
&          anthfac)
        m3acc = so4fac*chem_so4aj + conmin*(nh4fac+no3fac+orgfac*9+2*&
&          anthfac)
        m3cor = conmin*(soilfac+seasfac+anthfac)
!
! compute values for aerosol input data
!
        IF ((nch .EQ. p_nu0 .OR. nch .EQ. p_ac0) .OR. nch .EQ. p_corn) &
&        THEN
          xxlsgn = LOG(sginin)
          xxlsga = LOG(sginia)
          xxlsgc = LOG(sginic)
          l2sginin = xxlsgn**2
          l2sginia = xxlsga**2
          l2sginic = xxlsgc**2
          en1 = EXP(0.125*l2sginin)
          ea1 = EXP(0.125*l2sginia)
          ec1 = EXP(0.125*l2sginic)
          esn04 = en1**4
          esa04 = ea1**4
          esc04 = ec1**4
          esn08 = esn04*esn04
          esa08 = esa04*esa04
          esc08 = esc04*esc04
          esn16 = esn08*esn08
          esa16 = esa08*esa08
          esc16 = esc08*esc08
          esn20 = esn16*esn04
          esa20 = esa16*esa04
          esc20 = esc16*esc04
          esn36 = esn16*esn20
          esa36 = esa16*esa20
          esc36 = esc16*esc20
        END IF
!
! Units are something like number concentration
!
        IF (nch .EQ. p_nu0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (nch .EQ. p_ac0) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (nch .EQ. p_corn) THEN
          a_alt = a_alt + m3cor*a_chem/(dginic**3*esc36)
          a_chem = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          tempb2 = a_chem/(dginia**3*esa36)
          a_m3acc = alt*tempb2
          a_alt = a_alt + m3acc*tempb2
          a_chem = 0.0_8
        ELSE
          a_m3acc = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          tempb1 = a_chem/(dginin**3*esn36)
          a_m3nuc = alt*tempb1
          a_alt = a_alt + m3nuc*tempb1
          a_chem = 0.0_8
        ELSE
          a_m3nuc = 0.0_8
        END IF
        a_chem_so4aj = so4fac*a_m3acc
        a_chem_so4ai = so4fac*a_m3nuc
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_chem_so4ai = a_chem_so4ai + alt*a_chem
          a_alt = a_alt + chem_so4ai*a_chem
          a_chem = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_chem_so4aj = a_chem_so4aj + alt*a_chem
          a_alt = a_alt + chem_so4aj*a_chem
          a_chem = 0.0_8
        END IF
        tempb0 = mwso4*splitfac*so4vaptoaer*a_chem_so4aj
        tempb = (1.-splitfac)*mwso4*so4vaptoaer*a_chem_so4ai
        a_chemsulf_radm = convfac*tempb0 + convfac*tempb
        a_convfac = chemsulf_radm*tempb0 + chemsulf_radm*tempb
        a_stor = 0.0_8
        a_stor(iref(p_sulf-1)) = a_stor(iref(p_sulf-1)) + fracref(p_sulf&
&          -1)*1.e6*a_chemsulf_radm
        CALL POPCONTROL2B(branch)
        IF (branch .GE. 2) THEN
          IF (branch .NE. 2) THEN
            a_x1 = 0.0_8
            WHERE (.NOT.mask) a_x1 = a_stor(1:lo)
            a_wgt0 = SUM(cprof(2:lo+1, k)*a_x1) - SUM(cprof(2:lo+1, k+1)&
&              *a_x1)
            a_z = a_z + a_wgt0/(zprof(k)-zprof(k+1))
          END IF
          CALL POPINTEGER4(ad_count)
          DO i0=1,ad_count
            IF (i0 .EQ. 1) CALL POPCONTROL2B(branch)
          END DO
        END IF
      ELSE
        a_convfac = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_alt = a_alt + 10.e-5*a_chem
        a_chem = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_alt = a_alt + 10.e-5*a_chem
        a_chem = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_alt = a_alt + 10.e-5*a_chem
        a_chem = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_alt = a_alt + 10.e-5*a_chem
        a_chem = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_alt = a_alt + 1.e8*a_chem
        a_chem = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_alt = a_alt + 1.e8*a_chem
      a_chem = 0.0_8
    END IF
  END SUBROUTINE A_BDY_CHEM_VALUE_SORGAM
!  Differentiation of bdy_chem_value_racm in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: z chem
!   with respect to varying inputs: z chem
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE A_BDY_CHEM_VALUE_RACM(chem, a_chem, z, a_z, nch, numgas, &
&    p_co2)
    IMPLICIT NONE
    REAL :: chem
    REAL :: a_chem
! 3D height array
    REAL, INTENT(IN) :: z
    REAL :: a_z
! index number of chemical species
    INTEGER, INTENT(IN) :: nch, p_co2
! index number of last gas species
    INTEGER, INTENT(IN) :: numgas
    INTEGER :: i, k, irefcur
! chemical profile, diff. index order
    REAL, DIMENSION(kx) :: cprof
    REAL, DIMENSION(kx) :: zprof
    REAL :: stor
    REAL :: a_stor
    REAL :: wgt0
    REAL :: a_wgt0
    CHARACTER(len=80) :: message
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Check the number of species
!     if((nch-1).gt.logg)return
    IF (nch .EQ. p_co2) THEN
      a_chem = 0.0_8
    ELSE IF (nch .EQ. p_co2 + 1) THEN
      a_chem = 0.0_8
    ELSE IF (nch .LT. p_co2 + 2) THEN
!    if( nch .GT. logg+1) then
      IF (nch .LE. numgas) THEN
! Vertically flip the chemistry data as it is given top down 
!     and heights in zfa are bottom up
! Fill 1D chemical profile array cprof
! Convert species 28-34 (lo-6:lo) from (molecules/cm3) to (mol/mol)
        irefcur = iref(nch-1)
        DO k=1,kx
          zprof(k) = 0.5*(zfa_bdy(k)+zfa_bdy(k+1))
          IF (irefcur .LT. lo - 6) THEN
            cprof(k) = xl(irefcur, kx+1-k)
          ELSE
            cprof(k) = xl(irefcur, kx+1-k)/dens(kx+1-k)
          END IF
        END DO
! Interpolate temp 3D chemical profile array to WRF field
        IF (z .LT. zprof(1)) THEN
          CALL PUSHCONTROL3B(0)
        ELSE IF (z .GT. zprof(kx)) THEN
          CALL PUSHCONTROL3B(1)
        ELSE
          ad_count = 1
! We can trap between two levels and linearly interpolate
input_loop:DO k=1,kx-1
            IF (z .EQ. zprof(k)) THEN
              GOTO 100
            ELSE IF (z .GT. zprof(k) .AND. z .LT. zprof(k+1)) THEN
              GOTO 110
            ELSE
              ad_count = ad_count + 1
            END IF
          END DO input_loop
          CALL PUSHCONTROL2B(0)
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHCONTROL3B(2)
          GOTO 120
 100      CALL PUSHCONTROL2B(1)
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHCONTROL3B(2)
          GOTO 120
 110      CALL PUSHCONTROL2B(2)
          CALL PUSHINTEGER4(ad_count)
          wgt0 = (z-zprof(k+1))/(zprof(k)-zprof(k+1))
          IF (wgt0*cprof(k) + (1.-wgt0)*cprof(k+1) .LT. 0.) THEN
            CALL PUSHCONTROL3B(4)
          ELSE
            CALL PUSHCONTROL3B(3)
          END IF
        END IF
! Here is where the chemistry value is constructed
! special code for sulfate/h2so4
 120    IF (nch .EQ. p_sulf .AND. p_nu0 .GT. 1) a_chem = (1.-so4vaptoaer&
&            )*a_chem
        a_stor = fracref(nch-1)*1.e6*a_chem
        CALL POPCONTROL3B(branch)
        IF (branch .GE. 2) THEN
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              a_wgt0 = (cprof(k)-cprof(k+1))*a_stor
            ELSE
              a_wgt0 = 0.0_8
            END IF
            a_z = a_z + a_wgt0/(zprof(k)-zprof(k+1))
          END IF
          CALL POPINTEGER4(ad_count)
          DO i0=1,ad_count
            IF (i0 .EQ. 1) CALL POPCONTROL2B(branch)
          END DO
        END IF
        a_chem = 0.0_8
      END IF
    END IF
  END SUBROUTINE A_BDY_CHEM_VALUE_RACM
!  Differentiation of bdy_chem_value in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: z chem
!   with respect to varying inputs: z
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE A_BDY_CHEM_VALUE(chem, a_chem, z, a_z, nch, numgas)
    IMPLICIT NONE
    REAL :: chem
    REAL :: a_chem
! 3D height array
    REAL, INTENT(IN) :: z
    REAL :: a_z
! index number of chemical species
    INTEGER, INTENT(IN) :: nch
! index number of last gas species
    INTEGER, INTENT(IN) :: numgas
    INTEGER :: i, k, irefcur
! chemical profile, diff. index order
    REAL, DIMENSION(kx) :: cprof
    REAL, DIMENSION(kx) :: zprof
    REAL :: stor
    REAL :: a_stor
    REAL :: wgt0
    REAL :: a_wgt0
    CHARACTER(len=80) :: message
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Check the number of species
!     if((nch-1).gt.logg)return
! for radmkpp there is co2 and ch4 in the variable list
!
    IF (p_co2 .GT. 1) THEN
      IF (nch .EQ. p_co2) THEN
        GOTO 140
      ELSE IF (nch .EQ. p_ch4) THEN
        GOTO 140
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!     if( nch .GT. numgas) then
!       message = ' Input_chem_profile: wrong number of chemical species'
!       return
!       CALL WRF_ERROR_FATAL ( message )
!     endif
! Vertically flip the chemistry data as it is given top down 
!     and heights in zfa are bottom up
! Fill 1D chemical profile array cprof
! Convert species 28-34 (lo-6:lo) from (molecules/cm3) to (mol/mol)
    irefcur = iref(nch-1)
    DO k=1,kx
      zprof(k) = 0.5*(zfa_bdy(k)+zfa_bdy(k+1))
      IF (irefcur .LT. lo - 6) THEN
        cprof(k) = xl(irefcur, kx+1-k)
      ELSE
        cprof(k) = xl(irefcur, kx+1-k)/dens(kx+1-k)
      END IF
    END DO
! Interpolate temp 3D chemical profile array to WRF field
    IF (z .LT. zprof(1)) THEN
      CALL PUSHCONTROL3B(0)
    ELSE IF (z .GT. zprof(kx)) THEN
      CALL PUSHCONTROL3B(1)
    ELSE
      ad_count = 1
! We can trap between two levels and linearly interpolate
input_loop:DO k=1,kx-1
        IF (z .EQ. zprof(k)) THEN
          GOTO 100
        ELSE IF (z .EQ. zprof(k+1)) THEN
          GOTO 110
        ELSE IF (z .GT. zprof(k) .AND. z .LT. zprof(k+1)) THEN
          GOTO 120
        ELSE
          ad_count = ad_count + 1
        END IF
      END DO input_loop
      CALL PUSHCONTROL2B(0)
      CALL PUSHINTEGER4(ad_count)
      CALL PUSHCONTROL3B(2)
      GOTO 130
 100  CALL PUSHCONTROL2B(1)
      CALL PUSHINTEGER4(ad_count)
      CALL PUSHCONTROL3B(2)
      GOTO 130
 110  CALL PUSHCONTROL2B(2)
      CALL PUSHINTEGER4(ad_count)
      CALL PUSHCONTROL3B(2)
      GOTO 130
 120  CALL PUSHCONTROL2B(3)
      CALL PUSHINTEGER4(ad_count)
      wgt0 = (z-zprof(k+1))/(zprof(k)-zprof(k+1))
      IF (wgt0*cprof(k) + (1.-wgt0)*cprof(k+1) .LT. 0.) THEN
        CALL PUSHCONTROL3B(4)
      ELSE
        CALL PUSHCONTROL3B(3)
      END IF
    END IF
! Here is where the chemistry value is constructed
! special code for sulfate/h2so4
 130 IF (nch .EQ. p_sulf .AND. p_nu0 .GT. 1) a_chem = (1.-so4vaptoaer)*&
&        a_chem
    a_stor = fracref(nch-1)*1.e6*a_chem
    CALL POPCONTROL3B(branch)
    IF (branch .GE. 2) THEN
      IF (branch .NE. 2) THEN
        IF (branch .EQ. 3) THEN
          a_wgt0 = (cprof(k)-cprof(k+1))*a_stor
        ELSE
          a_wgt0 = 0.0_8
        END IF
        a_z = a_z + a_wgt0/(zprof(k)-zprof(k+1))
      END IF
      CALL POPINTEGER4(ad_count)
      DO i0=1,ad_count
        IF (i0 .EQ. 1) CALL POPCONTROL2B(branch)
      END DO
    END IF
    CALL POPCONTROL1B(branch)
 140 CONTINUE
  END SUBROUTINE A_BDY_CHEM_VALUE

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE A_BDY_CHEM_VALUE_GCM(chem, a_chem, chem_b, a_chem_b, &
&    chem_bt, a_chem_bt, dt, ic)
    IMPLICIT NONE
    REAL :: chem
    REAL :: a_chem
    REAL, INTENT(IN) :: chem_b
    REAL :: a_chem_b
    REAL, INTENT(IN) :: chem_bt
    REAL :: a_chem_bt
    REAL, INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: ic
    CHARACTER(len=80) :: message
    IF (epsilc .LT. chem_b + chem_bt*dt) THEN
      a_chem_b = a_chem_b + a_chem
      a_chem_bt = a_chem_bt + dt*a_chem
    END IF
  END SUBROUTINE A_BDY_CHEM_VALUE_GCM

!  Differentiation of sorgam_set_aer_bc_pnnl in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: z chem
!   with respect to varying inputs: z chem
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!****************************************************************
!                                                               *
!   SUBROUTINE TO SET AEROSOL BC VALUES USING THE               *
!   aer_bc_opt == aer_bc_pnnl OPTION.                           *
!                                                               *
!   wig 22-Apr-2004, original routine                           *
!       rce 25-apr-2004 - changed name to                       *
!                         "sorgam_set_aer_bc_pnnl"              *
!       wig  7-May-2004, added height dependance                *
!                                                               *
!   CALLS THE FOLLOWING SUBROUTINES:  NONE                      *
!                                                               *
!   CALLED BY:                        bdy_chem_value_sorgam     *
!                                                               *
!****************************************************************
  SUBROUTINE A_SORGAM_SET_AER_BC_PNNL(chem, a_chem, z, a_z, nch, &
&    config_flags)
    USE module_data_sorgam, ONLY : dginia, dginin, dginic, esn36, &
&    esc36, esa36, seasfac, no3fac, nh4fac, so4fac, soilfac, anthfac, &
&    orgfac
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nch
    REAL, INTENT(IN) :: z
    REAL :: a_z
    REAL, INTENT(INOUT) :: chem
    REAL, INTENT(INOUT) :: a_chem
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    REAL :: mult, m3acc, m3cor, m3nuc, bv_so4ai, bv_so4aj, bv_nh4ai, &
&    bv_nh4aj, bv_no3ai, bv_no3aj, bv_eci, bv_ecj, bv_p25i, bv_p25j, &
&    bv_orgpai, bv_orgpaj, bv_antha, bv_seas, bv_soila
    REAL :: a_mult, a_m3acc, a_m3cor, a_m3nuc, a_bv_so4ai, a_bv_so4aj, &
&    a_bv_nh4ai, a_bv_nh4aj, a_bv_no3ai, a_bv_no3aj, a_bv_eci, a_bv_ecj, &
&    a_bv_p25i, a_bv_p25j, a_bv_orgpai, a_bv_orgpaj, a_bv_antha, &
&    a_bv_seas
    INTEGER :: branch
!
! Determine height multiplier...
! This should mimic the calculation in sorgam_init_aer_ic_pnnl,
! mosaic_init_wrf_mixrats_opt2, and bdy_chem_value_mosaic
!!$!    Height(m)     Multiplier
!!$!    ---------     ----------
!!$!    <=2000        1.0
!!$!    2000<z<3000   linear transition zone to 0.5
!!$!    3000<z<5000   linear transision zone to 0.25
!!$!    >=5000        0.25
!!$!
!!$! which translates to:
!!$!    2000<z<3000   mult = 1.0 + (z-2000.)*(0.5-1.0)/(3000.-2000.)
!!$!    3000<z<5000   mult = 0.5 + (z-3000.)*(0.25-0.5)/(5000.-3000.)
!!$! or in reduced form:
!!$      if( z <= 2000. ) then
!!$         mult = 1.0
!!$      elseif( z > 2000. &
!!$           .and. z <= 3000. ) then
!!$         mult = 1.0 - 0.0005*(z-2000.)
!!$      elseif( z > 3000. &
!!$           .and. z <= 5000. ) then
!!$         mult = 0.5 - 1.25e-4*(z-3000.)
!!$      else
!!$         mult = 0.25
!!$      end if
! Updated aerosol profile multiplier 1-Apr-2005:
!    Height(m)     Multiplier
!    ---------     ----------
!    <=2000        1.0
!    2000<z<3000   linear transition zone to 0.25
!    3000<z<5000   linear transision zone to 0.125
!    >=5000        0.125
!
! which translates to:
!    2000<z<3000   mult = 1.00 + (z-2000.)*(0.25-1.0)/(3000.-2000.)
!    3000<z<5000   mult = 0.25 + (z-3000.)*(0.125-0.25)/(5000.-3000.)
! or in reduced form:
!       if( z <= 2000. ) then
!          mult = 1.0
!       elseif( z > 2000. &
!            .and. z <= 3000. ) then
!          mult = 1.0 - 0.00075*(z-2000.)
!       elseif( z > 3000. &
!            .and. z <= 5000. ) then
!          mult = 0.25 - 4.166666667e-5*(z-3000.)
!       else
!          mult = 0.125
!       end if
    IF (z .LE. 500.) THEN
      CALL PUSHCONTROL2B(0)
    ELSE IF (z .GT. 500. .AND. z .LE. 1000.) THEN
      CALL PUSHCONTROL2B(1)
    ELSE IF (z .GT. 1000. .AND. z .LE. 5000.) THEN
      CALL PUSHCONTROL2B(2)
    ELSE
      CALL PUSHCONTROL2B(3)
    END IF
! These should match what is in sorgam_init_aer_ic_pnnl.
! Boundary values as of 2-Dec-2004:
!     bv_so4aj  = mult*2.375
!     bv_so4ai  = mult*0.179
!     bv_nh4aj  = mult*0.9604
!     bv_nh4ai  = mult*0.0196
!     bv_no3aj  = mult*0.0650
!     bv_no3ai  = mult*0.0050
!     bv_ecj    = mult*0.1630
!     bv_eci    = mult*0.0120
!     bv_p25j   = mult*0.6350
!     bv_p25i   = mult*0.0490
!     bv_orgpaj = mult*0.9300
!     bv_orgpai = mult*0.0700
!     bv_antha  = mult*2.2970
!     bv_seas   = mult*0.2290
!     bv_soila  = conmin
! m3... calculations should match the very end of module_aerosols_sorgam.F
!... i-mode (note that the 8 SOA species have bv=conmin)
!... j-mode (note that the 8 SOA species have bv=conmin)
!...c-mode
! Cannot set_sulf here because it is a "radm2" species whose bc value
! is set via bdy_chem_value. Instead, xl(iref(p_sulf-1),:) is set to
! the value conmin in subroutine gasprofile_init_pnnl
!      if( nch == p_sulf    ) chem = conmin !as per rce's 0 recommendation
    IF (nch .EQ. p_so4aj) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_so4ai) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_nh4aj) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_nh4ai) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_no3aj) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_no3ai) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_ecj) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_eci) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_p25j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_p25i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgpaj) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgpai) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgaro1j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgaro1i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgaro2j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgaro2i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgalk1j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgalk1i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgole1j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgole1i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba1j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba1i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba2j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba2i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba3j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba3i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba4j) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_orgba4i) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_antha) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_soila) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_seas) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_nu0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_ac0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nch .EQ. p_corn) THEN
      a_m3cor = a_chem/(dginic**3*esc36)
      a_chem = 0.0_8
    ELSE
      a_m3cor = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_m3acc = a_chem/(dginia**3*esa36)
      a_chem = 0.0_8
    ELSE
      a_m3acc = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_m3nuc = a_chem/(dginin**3*esn36)
      a_chem = 0.0_8
    ELSE
      a_m3nuc = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_seas = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_seas = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_antha = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_antha = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_chem = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_orgpai = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_orgpai = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_orgpaj = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_orgpaj = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_p25i = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_p25i = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_p25j = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_p25j = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_eci = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_eci = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_ecj = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_ecj = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_no3ai = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_no3ai = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_no3aj = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_no3aj = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_nh4ai = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_nh4ai = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_nh4aj = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_nh4aj = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_so4ai = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_so4ai = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_bv_so4aj = a_chem
      a_chem = 0.0_8
    ELSE
      a_bv_so4aj = 0.0_8
    END IF
    a_bv_seas = a_bv_seas + seasfac*a_m3cor
    a_bv_antha = a_bv_antha + anthfac*a_m3cor
    a_bv_so4aj = a_bv_so4aj + so4fac*a_m3acc
    a_bv_nh4aj = a_bv_nh4aj + nh4fac*a_m3acc
    a_bv_no3aj = a_bv_no3aj + no3fac*a_m3acc
    a_bv_orgpaj = a_bv_orgpaj + orgfac*a_m3acc
    a_bv_p25j = a_bv_p25j + anthfac*a_m3acc
    a_bv_ecj = a_bv_ecj + anthfac*a_m3acc
    a_bv_so4ai = a_bv_so4ai + so4fac*a_m3nuc
    a_bv_nh4ai = a_bv_nh4ai + nh4fac*a_m3nuc
    a_bv_no3ai = a_bv_no3ai + no3fac*a_m3nuc
    a_bv_orgpai = a_bv_orgpai + orgfac*a_m3nuc
    a_bv_p25i = a_bv_p25i + anthfac*a_m3nuc
    a_bv_eci = a_bv_eci + anthfac*a_m3nuc
    a_mult = 0.03*0.088*a_bv_orgpai + 4.500*a_bv_antha/2.0 + 0.97*4.500*&
&      a_bv_p25j + 0.97*0.013*a_bv_ecj + 0.97*0.001*a_bv_no3aj + 0.97*&
&      0.094*a_bv_nh4aj + 0.97*0.300*a_bv_so4aj + 0.03*0.300*a_bv_so4ai +&
&      0.03*0.094*a_bv_nh4ai + 0.03*0.001*a_bv_no3ai + 0.03*0.013*&
&      a_bv_eci + 0.03*4.500*a_bv_p25i + 0.97*0.088*a_bv_orgpaj + 1.75*&
&      a_bv_seas
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .NE. 0) a_z = a_z - 0.001074*a_mult
    ELSE IF (branch .EQ. 2) THEN
      a_z = a_z - 0.000111*a_mult
    END IF
  END SUBROUTINE A_SORGAM_SET_AER_BC_PNNL
END MODULE a_module_input_chem_data

