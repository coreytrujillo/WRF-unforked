MODULE A_MODULE_DEP_SIMPLE
    USE module_dep_simple, only: kpart,rac,rclo,rcls,rgso,rgss,ri,rlu,ri_pan,     &
                                 c0_pan,k_pan,luse2usgs,dratio,hstar,hstar4,f0,   &
                                 dhr,scpr23,seasonal_pft,dep_seasons,nlu,         &
                                 small_value,large_value,isice_temp,iswater_temp, &
                                 wrf2mz_lt_map,wh2o,wpan,mminlu,month,ixxxlu
                                 
  IMPLICIT NONE
CONTAINS
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!  Differentiation of wesely_driver in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: ust ddvel znt rmol aer_res_def
!   with respect to varying inputs: ust t_phy znt rmol p_phy moist
!                z_at_w
  SUBROUTINE A_WESELY_DRIVER(id, ktau, dtstep, config_flags, &
&    current_month, gmt, julday, t_phy, a_t_phy, moist, a_moist, p8w, t8w&
&    , raincv, p_phy, a_p_phy, chem, rho_phy, dz8w, ddvel, a_ddvel, &
&    aer_res_def, a_aer_res_def, aer_res_zcen, ivgtyp, tsk, gsw, vegfra, &
&    pbl, rmol, a_rmol, ust, a_ust, znt, a_znt, xlat, xlong, z, z_at_w, &
&    a_z_at_w, snowh, numgas, ids, ide, jds, jde, kds, kde, ims, ime, jms&
&    , jme, kms, kme, its, ite, jts, jte, kts, kte)
    USE module_model_constants
    USE module_configure
    USE module_state_description
    USE module_dep_simple, only: rc,deppart
    IMPLICIT NONE
!--------------------------------------------------
!  Wesely dry dposition driver
!--------------------------------------------------
!  USE module_configure
    INTEGER, INTENT(IN) :: id, julday, numgas, current_month, ids, ide, &
&    jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte&
&    , kts, kte
    INTEGER, INTENT(IN) :: ktau
    REAL, INTENT(IN) :: dtstep, gmt
!--------------------------------------------------
! advected moisture variables
!--------------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    moist
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist) :: a_moist
!--------------------------------------------------
! advected chemical species
!--------------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: chem
!--------------------------------------------------
! deposition velocities
!--------------------------------------------------
    REAL, DIMENSION(its:ite, jts:jte, num_chem), INTENT(INOUT) :: ddvel
    REAL, DIMENSION(its:ite, jts:jte, num_chem), INTENT(INOUT) :: &
&    a_ddvel
!--------------------------------------------------
! input from met model
!--------------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy, &
&    p_phy, dz8w, z, t8w, p8w, z_at_w, rho_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_t_phy, a_p_phy, &
&    a_z_at_w
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: ivgtyp
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tsk, gsw, vegfra&
&    , pbl, rmol, ust, xlat, xlong, raincv, znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_rmol
    REAL, INTENT(INOUT) :: aer_res_def(its:ite, jts:jte)
    REAL, INTENT(INOUT) :: a_aer_res_def(its:ite, jts:jte)
    REAL, INTENT(INOUT) :: aer_res_zcen(its:ite, jts:jte)
    REAL, OPTIONAL, INTENT(IN) :: snowh(ims:ime, jms:jme)
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
!--------------------------------------------------
! .. Local Scalars
!--------------------------------------------------
    REAL :: clwchem, dvfog, dvpart, pa, rad, dep_vap
    REAL :: a_dvpart, a_pa
    REAL :: rhchem, ta, ustar, vegfrac, z1, zntt
    REAL :: a_rhchem, a_ustar, a_z1, a_zntt
    INTEGER :: i, iland, iprt, iseason, j, jce, jcs, n, nr, ipr, jpr, &
&    nvr
    LOGICAL :: highnh3, rainflag, vegflag, wetflag
!--------------------------------------------------
! .. Local Arrays
!--------------------------------------------------
    REAL :: p(kts:kte)
    REAL :: srfres(numgas)
    REAL :: a_srfres(numgas)
    REAL :: ddvel0d(numgas)
    REAL :: a_ddvel0d(numgas)
!-----------------------------------------------------------
! necessary for aerosols (module dependent)         
!-----------------------------------------------------------
    REAL :: rcx(numgas)
    REAL :: a_rcx(numgas)
!-----------------------------------------------------------
! .. Intrinsic Functions
!-----------------------------------------------------------
    REAL :: tmp
    REAL :: tmp0
    REAL :: tmp1
    INTEGER :: branch
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_znt
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    INTRINSIC EXP
    REAL :: tmp0b
    REAL :: tmp1b
    REAL :: tempb0
    REAL :: tempb
    REAL :: a_y1
    REAL :: temp
    REAL :: y1
    REAL :: tmpb
    IF (julday .LT. 90 .OR. julday .GT. 270) THEN
      iseason = 2
    ELSE
      iseason = 1
    END IF
tile_lat_loop:DO j=jts,jte
tile_lon_loop:DO i=its,ite
        iland = luse2usgs(ivgtyp(i, j))
!--
        ta = tsk(i, j)
        rad = gsw(i, j)
        CALL PUSHREAL8(pa)
        pa = 0.01D0*p_phy(i, kts, j)
        clwchem = moist(i, kts, j, p_qc)
        ustar = ust(i, j)
        CALL PUSHBOOLEAN(rainflag)
!-----------------------------------------------------------
!     Set logical default values
!-----------------------------------------------------------
        rainflag = .false.
        CALL PUSHBOOLEAN(wetflag)
        wetflag = .false.
        CALL PUSHBOOLEAN(highnh3)
        highnh3 = .false.
        IF (p_qr .GT. 1) THEN
          IF (moist(i, kts, j, p_qr) .GT. 1.d-18 .OR. raincv(i, j) .GT. &
&              0.D0) rainflag = .true.
        END IF
        y1 = 100.D0*moist(i, kts, j, p_qv)/(3.80D0*EXP(17.27D0*(t_phy(i, kts, &
&          j)-273.D0)/(t_phy(i, kts, j)-36.D0))/pa)
        IF (100.D0 .GT. y1) THEN
          CALL PUSHREAL8(rhchem)
          rhchem = y1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(rhchem)
          rhchem = 100.D0
          CALL PUSHCONTROL1B(1)
        END IF
        IF (5.D0 .LT. rhchem) THEN
          CALL PUSHCONTROL1B(0)
          rhchem = rhchem
        ELSE
          rhchem = 5.D0
          CALL PUSHCONTROL1B(1)
        END IF
        IF (rhchem .GE. 95.D0) wetflag = .true.
        IF (p_nh3 .GT. 1 .AND. p_so2 .GT. 1) THEN
          IF (chem(i, kts, j, p_nh3) .GT. 2.D0*chem(i, kts, j, p_so2)) &
&            highnh3 = .true.
        END IF
!-----------------------------------------------------------
!--- deposition
!-----------------------------------------------------------
!     if(snowc(i,j).gt.0.)iseason=4
        CALL RC(rcx, ta, rad, rhchem, iland, iseason, numgas, wetflag, &
&          rainflag, highnh3, iprt, moist(i, kts, j, p_qv), p8w(i, kts, j&
&          ), config_flags%chem_opt)
        if( config_flags%chem_opt /= MOZART_KPP .and. &
            config_flags%chem_opt /= MOZCART_KPP .and. &
            config_flags%chem_opt /= MOZART_MOSAIC_4BIN_KPP .and. &
            config_flags%chem_opt /= MOZART_MOSAIC_4BIN_AQ_KPP .and. &
            config_flags%chem_opt /= gocart_bc)  then
          CALL PUSHREAL8ARRAY(srfres(1:numgas-2), numgas - 2)
          srfres(1:numgas-2) = rcx(1:numgas-2)
          CALL PUSHREAL8ARRAY(srfres(numgas-1:numgas), 2)
          srfres(numgas-1:numgas) = 0.D0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8ARRAY(srfres, numgas)
          srfres(1:numgas) = rcx(1:numgas)
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(dvpart)
        CALL DEPPART(rmol(i, j), ustar, rhchem, clwchem, iland, dvpart, &
&               dvfog)
        CALL PUSHREAL8ARRAY(ddvel0d, numgas)
        ddvel0d(1:numgas) = 0.D0
!-----------------------------------------------------------
!wig: CBMZ does not have HO and HO2 last so need to copy all species
!      ddvel(i,j,1:numgas-2)=ddvel0d(1:numgas-2)
!-----------------------------------------------------------
      END DO tile_lon_loop
    END DO tile_lat_loop
! For gocartracm,radm
!-----------------------------------------------------------
    IF (config_flags%chem_opt .EQ. gocartracm_kpp .OR. &
&        config_flags%chem_opt .EQ. gocartradm2) THEN
      DO j=jts,jte
        DO i=its,ite
          IF (config_flags%chem_opt .EQ. gocartradm2) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!-----------------------------------------------------------
! For gocartsimple : need msa. On the other hand sulf comes from aerosol routine
!-----------------------------------------------------------
    IF (config_flags%chem_opt .EQ. gocart_simple) THEN
      DO j=jte,jts,-1
        DO i=ite,its,-1
          a_ddvel(i, j, p_dms) = 0.0_8
          a_ddvel(i, j, p_sulf) = 0.0_8
          tmp1b = a_ddvel(i, j, p_msa)
          a_ddvel(i, j, p_msa) = 0.0_8
          a_ddvel(i, j, p_sulf) = a_ddvel(i, j, p_sulf) + tmp1b
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=jte,jts,-1
        DO i=ite,its,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            tmp0b = a_ddvel(i, j, p_hcl)
            a_ddvel(i, j, p_hcl) = 0.0_8
            a_ddvel(i, j, p_hno3) = a_ddvel(i, j, p_hno3) + tmp0b
          END IF
          tmpb = a_ddvel(i, j, p_msa)
          a_ddvel(i, j, p_msa) = 0.0_8
          a_ddvel(i, j, p_hno3) = a_ddvel(i, j, p_hno3) + tmpb
          a_ddvel(i, j, p_dms) = 0.0_8
          a_ddvel(i, j, p_sulf) = 0.0_8
        END DO
      END DO
    END IF
    a_srfres = 0.0_8
    DO j=jte,jts,-1
      DO i=ite,its,-1
        a_ddvel0d = 0.0_8
        a_ddvel0d(1:numgas) = a_ddvel(i, j, 1:numgas)
        a_ddvel(i, j, 1:numgas) = 0.0_8
        ustar = ust(i, j)
        zntt = znt(i, j)
        z1 = z_at_w(i, kts+1, j) - z_at_w(i, kts, j)
        CALL A_LANDUSEVG(ddvel0d, a_ddvel0d, ustar, a_ustar, rmol(i, j)&
&                   , a_rmol(i, j), zntt, a_zntt, z1, a_z1, dvpart, &
&                   a_dvpart, iland, numgas, srfres, a_srfres, &
&                   aer_res_def(i, j), a_aer_res_def(i, j), aer_res_zcen(&
&                   i, j), p_sulf)
        a_aer_res_def(i, j) = 0.0_8
        a_aer_res_def(i, j) = 0.0_8
        CALL POPREAL8ARRAY(ddvel0d, numgas)
        iland = luse2usgs(ivgtyp(i, j))
        CALL POPREAL8(dvpart)
        CALL A_DEPPART(rmol(i, j), a_rmol(i, j), ustar, a_ustar, rhchem&
&                 , a_rhchem, clwchem, iland, dvpart, a_dvpart, dvfog)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(srfres(numgas-1:numgas), 2)
          a_srfres(numgas-1:numgas) = 0.0_8
          a_rcx = 0.0_8
          CALL POPREAL8ARRAY(srfres(1:numgas-2), numgas - 2)
          a_rcx(1:numgas-2) = a_rcx(1:numgas-2) + a_srfres(1:numgas-2)
          a_srfres(1:numgas-2) = 0.0_8
        ELSE
          a_rcx = 0.0_8
          CALL POPREAL8ARRAY(srfres, numgas)
          a_rcx(1:numgas) = a_srfres(1:numgas)
          a_srfres = 0.0_8
        END IF
        rad = gsw(i, j)
        ta = tsk(i, j)
        CALL A_RC(rcx, a_rcx, ta, rad, rhchem, a_rhchem, iland, iseason&
&            , numgas, wetflag, rainflag, highnh3, iprt, moist(i, kts, j&
&            , p_qv), p8w(i, kts, j), config_flags%chem_opt)
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) a_rhchem = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(rhchem)
          a_y1 = a_rhchem
        ELSE
          CALL POPREAL8(rhchem)
          a_y1 = 0.0_8
        END IF
        temp2 = t_phy(i, kts, j) - 36.D0
        temp = (t_phy(i, kts, j)-273.D0)/temp2
        temp1 = 3.80D0*EXP(17.27D0*temp)
        temp0 = moist(i, kts, j, p_qv)
        tempb = 100.D0*a_y1/temp1
        tempb0 = -(17.27D0*EXP(17.27D0*temp)*3.80D0*temp0*pa*tempb/(temp1*&
&          temp2))
        a_moist(i, kts, j, p_qv) = a_moist(i, kts, j, p_qv) + pa*tempb
        a_pa = temp0*tempb
        a_t_phy(i, kts, j) = a_t_phy(i, kts, j) + (1.0D0-temp)*tempb0
        CALL POPBOOLEAN(highnh3)
        CALL POPBOOLEAN(wetflag)
        CALL POPBOOLEAN(rainflag)
        a_z_at_w(i, kts+1, j) = a_z_at_w(i, kts+1, j) + a_z1
        a_z_at_w(i, kts, j) = a_z_at_w(i, kts, j) - a_z1
        a_znt(i, j) = a_znt(i, j) + a_zntt
        a_ust(i, j) = a_ust(i, j) + a_ustar
        CALL POPREAL8(pa)
        a_p_phy(i, kts, j) = a_p_phy(i, kts, j) + 0.01D0*a_pa
      END DO
    END DO
  END SUBROUTINE A_WESELY_DRIVER

!  Differentiation of rc in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: rh rcx
!   with respect to varying inputs: rh
  SUBROUTINE A_RC(rcx, a_rcx, t, rad, rh, a_rh, iland, iseason, numgas, &
&    wetflag, rainflag, highnh3, iprt, spec_hum, p_srf, chem_opt)
    USE MODULE_STATE_DESCRIPTION
    IMPLICIT NONE
!----------------------------------------------------------------------
!     THIS SUBROUTINE CALCULATES SURFACE RESISTENCES ACCORDING
!     TO THE MODEL OF
!     M. L. WESELY,
!     ATMOSPHERIC ENVIRONMENT 23 (1989), 1293-1304
!     WITH SOME ADDITIONS ACCORDING TO
!     J. W. ERISMAN, A. VAN PUL, AND P. WYERS,
!     ATMOSPHERIC ENVIRONMENT 28 (1994), 2595-2607
!     WRITTEN BY  WINFRIED SEIDL, APRIL 1997
!     MODYFIED BY WINFRIED SEIDL, MARCH 2000
!                    FOR MM5 VERSION 3
!----------------------------------------------------------------------
!----------------------------------------------------------------------
!	... dummy arguments
!----------------------------------------------------------------------
    INTEGER, INTENT(IN) :: iland, iseason, numgas
    INTEGER, INTENT(IN) :: iprt
    INTEGER, INTENT(IN) :: chem_opt
    REAL, INTENT(IN) :: rad, rh
    REAL :: a_rh
! surface temp (K)
    REAL, INTENT(IN) :: t
! surface pressure (Pa)
    REAL, INTENT(IN) :: p_srf
! surface specific humidity (kg/kg)
    REAL, INTENT(IN) :: spec_hum
    REAL :: rcx(numgas)
    REAL :: a_rcx(numgas)
    LOGICAL, INTENT(IN) :: highnh3, rainflag, wetflag
!----------------------------------------------------------------------
! .. Local Scalars ..
!----------------------------------------------------------------------
    REAL, PARAMETER :: t0=298.D0
    REAL, PARAMETER :: tmelt=273.16D0
    INTEGER :: lt, n
    REAL :: rclx, rdc, resice, rgsx, rluo1, rluo2
    REAL :: rlux, rmx, rs, rsmx, rdtheta, z, wrk
    REAL :: a_rlux
    REAL :: qs, es, ws, dewm, dv_pan, drat
    REAL :: crs, tc
    REAL :: rs_pan, tc_pan
    LOGICAL :: has_dew
!----------------------------------------------------------------------
! .. Local Arrays ..
!----------------------------------------------------------------------
    REAL :: hstary(numgas)
!----------------------------------------------------------------------
! .. Intrinsic Functions ..
!----------------------------------------------------------------------
    INTRINSIC EXP
    INTEGER :: branch
    INTRINSIC MAX
    REAL :: temp
    rcx(1:numgas) = 1.D0
    tc = t - 273.15D0
    rdtheta = 0.D0
    z = 200.D0/(rad+0.1D0)
!!!  HARDWIRE VALUES FOR TESTING
!       z=0.4727409
!       tc=22.76083
!       t=tc+273.15
!       rad = 412.8426
!       rainflag=.false.
!       wetflag=.false.
    IF (tc .LE. 0. .OR. tc .GE. 40.) THEN
      rs = 9999.D0
    ELSE
      rs = ri(iland, iseason)*(1.D0+z*z)*(400.D0/(tc*(40.D0-tc)))
    END IF
    rdc = 100.D0*(1.D0+1000.D0/(rad+10.D0))/(1.D0+1000.D0*rdtheta)
    rluo1 = 1.D0/(1.D0/3000.D0+3.D0/rlu(iland, iseason))
    rluo2 = 1.D0/(1.D0/1000.D0+3.D0/rlu(iland, iseason))
    resice = 1000.D0*EXP(-(tc+4.D0))
    wrk = (t0-t)/(t0*t)
    DO n=1,numgas
      IF (hstar(n) .NE. 0.) THEN
        hstary(n) = hstar(n)*EXP(dhr(n)*wrk)
        rmx = 1.D0/(hstary(n)/3000.D0+100.D0*f0(n))
        rsmx = rs*dratio(n) + rmx
        rclx = 1.D0/(1.d-5*hstary(n)/rcls(iland, iseason)+f0(n)/rclo(iland&
&          , iseason)) + resice
        rgsx = 1.D0/(1.d-5*hstary(n)/rgss(iland, iseason)+f0(n)/rgso(iland&
&          , iseason)) + resice
        rlux = rlu(iland, iseason)/(1.d-5*hstary(n)+f0(n)) + resice
        IF (wetflag) rlux = 1.D0/(1.D0/(3.D0*rlu(iland, iseason))+1.d-7*hstary&
&            (n)+f0(n)/rluo1)
        IF (rainflag) rlux = 1.D0/(1.D0/(3.D0*rlu(iland, iseason))+1.d-7*&
&            hstary(n)+f0(n)/rluo2)
        rcx(n) = 1.D0/(1.D0/rsmx+1.D0/rlux+1.D0/(rdc+rclx)+1.D0/(rac(iland, &
&          iseason)+rgsx))
        IF (1. .LT. rcx(n)) THEN
          rcx(n) = rcx(n)
        ELSE
          rcx(n) = 1.D0
        END IF
      END IF
    END DO
!--------------------------------------------------
!     SO2 according to Erisman et al. 1994
!       R_STOM
!--------------------------------------------------
    IF (p_so2 .GT. 1) THEN
      rsmx = rs*dratio(p_so2)
!--------------------------------------------------
!       R_EXT
!--------------------------------------------------
      IF (tc .GT. -1.) THEN
        IF (rh .LT. 81.3D0) THEN
          rlux = 25000.D0*EXP(-(0.0693D0*rh))
          CALL PUSHCONTROL2B(0)
        ELSE
          rlux = 0.58d12*EXP(-(0.278D0*rh))
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      IF ((wetflag .OR. rainflag) .AND. tc .GT. -1.) THEN
        rlux = 1.
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (tc .GE. -5. .AND. tc .LE. -1.) THEN
        rlux = 200.D0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (tc .LT. -5.) THEN
        rlux = 500.D0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!--------------------------------------------------
!       INSTEAD OF R_INC R_CL and R_DC of Wesely are used
!--------------------------------------------------
      rclx = rcls(iland, iseason)
!--------------------------------------------------
!       DRY SURFACE
!--------------------------------------------------
      rgsx = 1000.D0
!--------------------------------------------------
!       WET SURFACE
!--------------------------------------------------
      IF (wetflag .OR. rainflag) THEN
        IF (highnh3) THEN
          rgsx = 0.D0
        ELSE
          rgsx = 500.D0
        END IF
      END IF
!--------------------------------------------------
!       WATER
!--------------------------------------------------
      IF (iland .EQ. iswater_temp) rgsx = 0.D0
!--------------------------------------------------
!       SNOW
!--------------------------------------------------
      IF (iseason .EQ. 4 .OR. iland .EQ. isice_temp) THEN
        IF (tc .GT. 2.) THEN
          rgsx = 0.D0
        ELSE IF (tc .GE. -1. .AND. tc .LE. 2.) THEN
          rgsx = 70.D0*(2.D0-tc)
        ELSE IF (tc .LT. -1.) THEN
          rgsx = 500.D0
        END IF
      END IF
!--------------------------------------------------
!       TOTAL SURFACE RESISTENCE
!--------------------------------------------------
      IF (iseason .NE. 4 .AND. ixxxlu(iland) .NE. 1 .AND. iland .NE. &
&          iswater_temp .AND. iland .NE. isice_temp) THEN
        rcx(p_so2) = 1.D0/(1.D0/rsmx+1.D0/rlux+1.D0/(rclx+rdc+rgsx))
        CALL PUSHCONTROL1B(1)
      ELSE
        rcx(p_so2) = rgsx
        CALL PUSHCONTROL1B(0)
      END IF
      IF (1. .GE. rcx(p_so2)) a_rcx(p_so2) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_rlux = 0.0_8
      ELSE
        temp = 1.0D0/rsmx + 1.0D0/(rclx+rdc+rgsx) + 1.0D0/rlux
        a_rlux = a_rcx(p_so2)/(rlux**2*temp**2)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_rlux = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_rlux = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_rlux = 0.0_8
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        a_rh = a_rh - EXP(-(0.0693D0*rh))*25000.D0*0.0693D0*a_rlux
      ELSE IF (branch .EQ. 1) THEN
        a_rh = a_rh - EXP(-(0.278D0*rh))*0.58d12*0.278D0*a_rlux
      END IF
    END IF
  END SUBROUTINE A_RC

!  Differentiation of deppart in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: ustar dvpart rmol
!   with respect to varying inputs: ustar rh rmol
  SUBROUTINE A_DEPPART(rmol, a_rmol, ustar, a_ustar, rh, a_rh, clw, &
&    iland, dvpart, a_dvpart, dvfog)
    IMPLICIT NONE
!--------------------------------------------------
!     THIS SUBROUTINE CALCULATES SURFACE DEPOSITION VELOCITIES
!     FOR FINE AEROSOL PARTICLES ACCORDING TO THE MODEL OF
!     J. W. ERISMAN, A. VAN PUL, AND P. WYERS,
!     ATMOSPHERIC ENVIRONMENT 28 (1994), 2595-2607
!     WRITTEN BY WINFRIED SEIDL, APRIL 1997
!     MODIFIED BY WINFRIED SEIDL, MARCH 2000
!            FOR MM5 VERSION 3
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: iland
    REAL, INTENT(IN) :: clw, rh, rmol, ustar
    REAL :: a_rh, a_rmol, a_ustar
    REAL :: dvfog, dvpart
    REAL :: a_dvpart
!--------------------------------------------------
! .. Intrinsic Functions ..
!--------------------------------------------------
    INTRINSIC EXP
    INTEGER :: branch
    CALL PUSHREAL8(dvpart)
    dvpart = ustar/kpart(iland)
    IF (rmol .LT. 0.) THEN
      CALL PUSHREAL8(dvpart)
!--------------------------------------------------
!         UNSTABLE LAYERING CORRECTION
!--------------------------------------------------
      dvpart = dvpart*(1.D0+(-(300.D0*rmol))**0.66667D0)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (rh .GT. 80.) THEN
      a_rh = EXP((rh-80.D0)/20.D0)*0.37D0*dvpart*a_dvpart/20.D0
      a_dvpart = (0.37D0*EXP((rh-80.D0)/20.D0)+1.D0)*a_dvpart
    ELSE
      a_rh = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(dvpart)
      a_rmol = a_rmol - 0.66667D0*(-(300.D0*rmol))**(-0.33333D0)*dvpart*300.D0*&
&        a_dvpart
      a_dvpart = ((-(300.D0*rmol))**0.66667D0+1.D0)*a_dvpart
    END IF
    CALL POPREAL8(dvpart)
    a_ustar = a_ustar + a_dvpart/kpart(iland)
  END SUBROUTINE A_DEPPART

!  Differentiation of landusevg in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: vgs srfres rmol aer_res_def
!   with respect to varying inputs: zz ustar z0 srfres dvparx rmol
  SUBROUTINE A_LANDUSEVG(vgs, a_vgs, ustar, a_ustar, rmol, a_rmol, z0, &
&    a_z0, zz, a_zz, dvparx, a_dvparx, iland, numgas, srfres, a_srfres, &
&    aer_res_def, a_aer_res_def, aer_res_zcen, p_sulf)
    USE MODULE_MODEL_CONSTANTS, ONLY : karman
    USE module_dep_simple, only: depvel

    IMPLICIT NONE
!--------------------------------------------------
!     This subroutine calculates the species specific deposition velocit
!     as a function of the local meteorology and land use.  The depositi
!     Velocity is also landuse specific.
!     Reference: Hsieh, C.M., Wesely, M.L. and Walcek, C.J. (1986)
!                A Dry Deposition Module for Regional Acid Deposition
!                EPA report under agreement DW89930060-01
!     Revised version by Darrell Winner (January 1991)
!        Environmental Engineering Science 138-78
!           California Institute of Technology
!              Pasadena, CA  91125
!     Modified by Winfried Seidl (August 1997)
!       Fraunhofer-Institut fuer Atmosphaerische Umweltforschung
!                    Garmisch-Partenkirchen, D-82467
!          for use of Wesely and Erisman surface resistances
!     Inputs:
!        Ustar  : The grid average friction velocity (m/s)
!        Rmol   : Reciprocal of the Monin-Obukhov length (1/m)
!        Z0     : Surface roughness height for the grid square (m)
!        SrfRes : Array of landuse/atmospheric/species resistances (s/m)
!        Slist  : Array of chemical species codes
!        Dvparx : Array of surface deposition velocity of fine aerosol p
!     Outputs:
!        Vgs    : Array of species and landuse specific deposition
!                 velocities (m/s)
!        Vg     : Cell-average deposition velocity by species (m/s)
!     Variables used:
!        SCPR23  : (Schmidt #/Prandtl #)**(2/3) Diffusion correction fac
!        Zr      : Reference Height (m)
!        Iatmo   : Parameter specifying the stabilty class (Function of
!        Z0      : Surface roughness height (m)
!        karman  : Von Karman constant (from module_model_constants)
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: iland, numgas, p_sulf
    REAL, INTENT(IN) :: dvparx, ustar, z0, zz
    REAL :: a_dvparx, a_ustar, a_z0, a_zz
    REAL, INTENT(INOUT) :: rmol
    REAL, INTENT(INOUT) :: a_rmol
    REAL, INTENT(INOUT) :: aer_res_def
    REAL, INTENT(INOUT) :: a_aer_res_def
    REAL, INTENT(INOUT) :: aer_res_zcen
    REAL :: a_aer_res_zcen
!--------------------------------------------------
! .. Array Arguments ..
!--------------------------------------------------
    REAL, INTENT(IN) :: srfres(numgas)
    REAL :: a_srfres(numgas)
    REAL :: vgs(numgas)
    REAL :: a_vgs(numgas)
!--------------------------------------------------
! .. Local Scalars ..
!--------------------------------------------------
    INTEGER :: jspec
    REAL :: vgp, vgpart, zr
    REAL :: a_vgp, a_vgpart, a_zr
    REAL :: rmol_tmp
    REAL :: a_rmol_tmp
!--------------------------------------------------
! .. Local Arrays ..
!--------------------------------------------------
    REAL :: vgspec(numgas)
    REAL :: a_vgspec(numgas)
    REAL :: temp0
    REAL :: temp0b
    REAL :: tempb
    REAL :: temp
!--------------------------------------------------
!   Calculate aerodynamic resistance for reference
!   height = layer center
!--------------------------------------------------
    zr = zz*.5D0
    rmol_tmp = rmol
    CALL PUSHREAL8(rmol_tmp)
    CALL DEPVEL(numgas, rmol_tmp, zr, z0, ustar, vgspec, vgpart, &
&          aer_res_zcen)
!--------------------------------------------------
!   Set the reference height (2.0 m)
!--------------------------------------------------
!       zr = 10.0
    zr = 2.0D0
    CALL PUSHREAL8(rmol)
!--------------------------------------------------
!   CALCULATE THE DEPOSITION VELOCITY without any surface
!   resistance term, i.e. 1 / (ra + rb)
!--------------------------------------------------
    CALL DEPVEL(numgas, rmol, zr, z0, ustar, vgspec, vgpart, aer_res_def&
&         )
!--------------------------------------------------
!   Calculate the deposition velocity for each species
!   and grid cell by looping through all the possibile combinations
!   of the two
!--------------------------------------------------
    vgp = 1.0D0/(1.0D0/vgpart+1.0D0/dvparx)
!--------------------------------------------------
!   Loop through the various species
!--------------------------------------------------
    DO jspec=1,numgas
!--------------------------------------------------
!   Add in the surface resistance term, rc (SrfRes)
!--------------------------------------------------
      vgs(jspec) = 1.0D0/(1.0D0/vgspec(jspec)+srfres(jspec))
    END DO
    vgs(p_sulf) = vgp
    CALL A_CELLVG(vgs, a_vgs, ustar, a_ustar, zz, a_zz, zr, rmol, a_rmol&
&            , numgas)
    a_vgp = a_vgs(p_sulf)
    a_vgs(p_sulf) = 0.0_8
    a_vgspec = 0.0_8
    DO jspec=numgas,1,-1
      temp0 = 1.0D0/vgspec(jspec)
      temp0b = -(a_vgs(jspec)/(temp0+srfres(jspec))**2)
      a_vgspec(jspec) = a_vgspec(jspec) - temp0*temp0b/vgspec(jspec)
      a_srfres(jspec) = a_srfres(jspec) + temp0b
      a_vgs(jspec) = 0.0_8
    END DO
    temp = 1.0D0/vgpart + 1.0D0/dvparx
    tempb = -(a_vgp/temp**2)
    a_vgpart = -(tempb/vgpart**2)
    a_dvparx = -(tempb/dvparx**2)
    CALL POPREAL8(rmol)
    a_z0 = 0.0_8
    CALL A_DEPVEL(numgas, rmol, a_rmol, zr, a_zr, z0, a_z0, ustar, &
&            a_ustar, vgspec, a_vgspec, vgpart, a_vgpart, aer_res_def, &
&            a_aer_res_def)
    zr = zz*.5D0
    CALL POPREAL8(rmol_tmp)
    a_rmol_tmp = 0.0_8
    a_vgpart = 0.0_8
    a_aer_res_zcen = 0.0_8
    CALL A_DEPVEL(numgas, rmol_tmp, a_rmol_tmp, zr, a_zr, z0, a_z0, &
&            ustar, a_ustar, vgspec, a_vgspec, vgpart, a_vgpart, &
&            aer_res_zcen, a_aer_res_zcen)
    a_rmol = a_rmol + a_rmol_tmp
    a_zz = a_zz + .5D0*a_zr
  END SUBROUTINE A_LANDUSEVG

!  Differentiation of cellvg in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: rmol vgtemp
!   with respect to varying inputs: ustar dz rmol vgtemp
  SUBROUTINE A_CELLVG(vgtemp, a_vgtemp, ustar, a_ustar, dz, a_dz, zr, &
&    rmol, a_rmol, nspec)
    USE MODULE_MODEL_CONSTANTS, ONLY : karman
    IMPLICIT NONE
!--------------------------------------------------
!     THIS PROGRAM HAS BEEN DESIGNED TO CALCULATE THE CELL AVERAGE
!     DEPOSITION VELOCITY GIVEN THE VALUE OF VG AT SOME REFERENCE
!     HEIGHT ZR WHICH IS MUCH SMALLER THAN THE CELL HEIGHT DZ.
!       PROGRAM WRITTEN BY GREGORY J.MCRAE (NOVEMBER 1977)
!         Modified by Darrell A. Winner    (February 1991)
!.....PROGRAM VARIABLES...
!     VgTemp   - DEPOSITION VELOCITY AT THE REFERENCE HEIGHT
!     USTAR    - FRICTION VELOCITY
!     RMOL     - RECIPROCAL OF THE MONIN-OBUKHOV LENGTH
!     ZR       - REFERENCE HEIGHT
!     DZ       - CELL HEIGHT
!     CELLVG   - CELL AVERAGE DEPOSITION VELOCITY
!     VK       - VON KARMAN CONSTANT
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: nspec
    REAL, INTENT(IN) :: dz, rmol, ustar, zr
    REAL :: a_dz, a_rmol, a_ustar
!--------------------------------------------------
! .. Array Arguments ..
!--------------------------------------------------
    REAL :: vgtemp(nspec)
    REAL :: a_vgtemp(nspec)
!--------------------------------------------------
! .. Local Scalars ..
!--------------------------------------------------
    INTEGER :: nss
    REAL :: a, fac, pdz, pzr, vk
    REAL :: a_a, a_fac, a_pdz, a_pzr
!--------------------------------------------------
! .. Intrinsic Functions ..
!--------------------------------------------------
    INTRINSIC ALOG, SQRT
    INTEGER :: branch
    REAL :: temp0
    REAL :: temp0b
    REAL :: tempb6
    REAL :: tempb5
    REAL :: tempb4
    REAL :: tempb3
    REAL :: tempb2
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
    REAL :: temp
!--------------------------------------------------
!     Set the von Karman constant
!--------------------------------------------------
    vk = karman
!--------------------------------------------------
!     DETERMINE THE STABILITY BASED ON THE CONDITIONS
!             1/L < 0 UNSTABLE
!             1/L = 0 NEUTRAL
!             1/L > 0 STABLE
!--------------------------------------------------
    DO nss=1,nspec
      IF (rmol .LT. 0.) THEN
        CALL PUSHREAL8(pdz)
        pdz = SQRT(1.0D0 - 9.0D0*dz*rmol)
        CALL PUSHREAL8(pzr)
        pzr = SQRT(1.0D0 - 9.0D0*zr*rmol)
        fac = (pdz-1.0D0)/(pzr-1.0D0)*((pzr+1.0D0)/(pdz+1.0D0))
        CALL PUSHREAL8(a)
        a = 0.74D0*dz*ALOG(fac) + 0.164D0/rmol*(pdz-pzr)
        CALL PUSHCONTROL2B(0)
      ELSE IF (rmol .EQ. 0.) THEN
        CALL PUSHREAL8(a)
        a = 0.74D0*(dz*ALOG(dz/zr)-dz+zr)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHREAL8(a)
        a = 0.74D0*(dz*ALOG(dz/zr)-dz+zr) + 2.35D0*rmol*(dz-zr)**2
        CALL PUSHCONTROL2B(2)
      END IF
    END DO
    a_ustar = 0.0_8
    a_dz = 0.0_8
    DO nss=nspec,1,-1
      temp0 = vk*ustar*(dz-zr)
      temp = vgtemp(nss)*a/temp0
      tempb5 = a_vgtemp(nss)/(temp+1.0D0)
      tempb6 = -(vgtemp(nss)*tempb5/((temp+1.0D0)*temp0))
      temp0b = -(temp*tempb6)
      a_a = vgtemp(nss)*tempb6
      a_ustar = a_ustar + (dz-zr)*vk*temp0b
      a_dz = a_dz + vk*ustar*temp0b
      a_vgtemp(nss) = a*tempb6 + tempb5
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        fac = (pdz-1.0D0)/(pzr-1.0D0)*((pzr+1.0D0)/(pdz+1.0D0))
        CALL POPREAL8(a)
        tempb = 0.164D0*a_a/rmol
        a_fac = dz*0.74D0*a_a/fac
        tempb1 = a_fac/((pzr-1.0D0)*(pdz+1.0D0))
        tempb2 = -((pdz-1.0D0)*(pzr+1.0D0)*tempb1/((pzr-1.0D0)*(pdz+1.0D0)))
        a_pdz = (pzr+1.0D0)*tempb1 + (pzr-1.0D0)*tempb2 + tempb
        a_pzr = (pdz-1.0D0)*tempb1 + (pdz+1.0D0)*tempb2 - tempb
        IF (1.0D0 - 9.0D0*(dz*rmol) .EQ. 0.0_8) THEN
          tempb0 = 0.0D0
        ELSE
          tempb0 = -(9.0D0*a_pdz/(2.0D0*SQRT(1.0D0-9.0D0*(dz*rmol))))
        END IF
        a_dz = a_dz + rmol*tempb0 + 0.74D0*ALOG(fac)*a_a
        IF (1.0D0 - zr*9.0D0*rmol .EQ. 0.0_8) THEN
          a_rmol = a_rmol + dz*tempb0 - (pdz-pzr)*tempb/rmol
        ELSE
          a_rmol = a_rmol + dz*tempb0 - zr*9.0D0*a_pzr/(2.0D0*SQRT(1.0D0-zr*&
&            9.0D0*rmol)) - (pdz-pzr)*tempb/rmol
        END IF
        CALL POPREAL8(pzr)
        CALL POPREAL8(pdz)
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8(a)
        tempb3 = 0.74D0*a_a
        a_dz = a_dz + ALOG(dz/zr)*tempb3
      ELSE
        CALL POPREAL8(a)
        tempb4 = 0.74D0*a_a
        a_dz = a_dz + rmol*2.35D0*2.D0*(dz-zr)*a_a + ALOG(dz/zr)*tempb4
        a_rmol = a_rmol + 2.35D0*(dz-zr)**2*a_a
      END IF
    END DO
  END SUBROUTINE A_CELLVG

!  Differentiation of depvel in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: ustar z0 aer_res vgpart depv
!                rmol
!   with respect to varying inputs: ustar z0 depv rmol zr
  SUBROUTINE A_DEPVEL(numgas, rmol, a_rmol, zr, a_zr, z0, a_z0, ustar, &
&    a_ustar, depv, a_depv, vgpart, a_vgpart, aer_res, a_aer_res)
    USE MODULE_MODEL_CONSTANTS, ONLY : karman
    IMPLICIT NONE
!--------------------------------------------------
!     THIS FUNCTION HAS BEEN DESIGNED TO EVALUATE AN UPPER LIMIT
!     FOR THE POLLUTANT DEPOSITION VELOCITY AS A FUNCTION OF THE
!     SURFACE ROUGHNESS AND METEOROLOGICAL CONDITIONS.
!     PROGRAM WRITTEN BY GREGORY J.MCRAE (NOVEMBER 1977)
!         Modified by Darrell A. Winner  (Feb. 1991)
!                  by Winfried Seidl     (Aug. 1997)
!.....PROGRAM VARIABLES...
!     RMOL     - RECIPROCAL OF THE MONIN-OBUKHOV LENGTH
!     ZR       - REFERENCE HEIGHT
!     Z0       - SURFACE ROUGHNESS HEIGHT
!     SCPR23   - (Schmidt #/Prandtl #)**(2/3) Diffusion correction fact
!     UBAR     - ABSOLUTE VALUE OF SURFACE WIND SPEED
!     DEPVEL   - POLLUTANT DEPOSITION VELOCITY
!     Vk       - VON KARMAN CONSTANT
!     USTAR    - FRICTION VELOCITY U*
!     POLINT   - POLLUTANT INTEGRAL
!     AER_RES  - AERODYNAMIC RESISTANCE
!.....REFERENCES...
!     MCRAE, G.J. ET AL. (1983) MATHEMATICAL MODELING OF PHOTOCHEMICAL
!       AIR POLLUTION, ENVIRONMENTAL QUALITY LABORATORY REPORT 18,
!       CALIFORNIA INSTITUTE OF TECHNOLOGY, PASADENA, CALIFORNIA.
!.....RESTRICTIONS...
!     1. THE MODEL EDDY DIFFUSIVITIES ARE BASED ON MONIN-OBUKHOV
!        SIMILARITY THEORY AND SO ARE ONLY APPLICABLE IN THE
!        SURFACE LAYER, A HEIGHT OF O(30M).
!     2. ALL INPUT UNITS MUST BE CONSISTENT
!     3. THE PHI FUNCTIONS USED TO CALCULATE THE FRICTION
!        VELOCITY U* AND THE POLLUTANT INTEGRALS ARE BASED
!        ON THE WORK OF BUSINGER ET AL.(1971).
!     4. THE MOMENTUM AND POLLUTANT DIFFUSIVITIES ARE NOT
!        THE SAME FOR THE CASES L<0 AND L>0.
!--------------------------------------------------
!--------------------------------------------------
! .. Scalar Arguments ..
!--------------------------------------------------
    INTEGER, INTENT(IN) :: numgas
    REAL, INTENT(IN) :: ustar, z0, zr
    REAL :: a_ustar, a_z0, a_zr
    REAL :: vgpart, aer_res
    REAL :: a_vgpart, a_aer_res
    REAL, INTENT(INOUT) :: rmol
    REAL, INTENT(INOUT) :: a_rmol
!--------------------------------------------------
! .. Array Arguments ..
!--------------------------------------------------
    REAL :: depv(numgas)
    REAL :: a_depv(numgas)
!--------------------------------------------------
! .. Local Scalars ..
!--------------------------------------------------
    INTEGER :: l
    REAL :: ao, ar, polint, vk
    REAL :: a_ao, a_ar, a_polint
!--------------------------------------------------
! .. Intrinsic Functions ..
!--------------------------------------------------
    INTRINSIC ALOG
    INTEGER :: branch
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp0b
    REAL :: temp1b
    REAL :: temp2b
    INTRINSIC MAX
    INTRINSIC ABS
    REAL :: temp3b
    REAL :: temp4b
    REAL :: a_max2
    REAL :: temp4b0
    REAL :: tempb
    REAL :: abs0
    REAL :: temp3b2
    REAL :: temp3b1
    REAL :: temp3b0
    REAL :: temp
    REAL :: max2
!--------------------------------------------------
!     Set the von Karman constant
!--------------------------------------------------
    vk = karman
    IF (rmol .GE. 0.) THEN
      abs0 = rmol
    ELSE
      abs0 = -rmol
    END IF
!--------------------------------------------------
!     Calculate the diffusion correction factor
!     SCPR23 is calculated as (Sc/Pr)**(2/3) using Sc= 1.15 and Pr= 1.0
!     SCPR23 = 1.10
!--------------------------------------------------
!     DETERMINE THE STABILITY BASED ON THE CONDITIONS
!             1/L < 0 UNSTABLE
!             1/L = 0 NEUTRAL
!             1/L > 0 STABLE
!--------------------------------------------------
    IF (abs0 .LT. 1.d-6) THEN
      CALL PUSHREAL8(rmol)
      rmol = 0.D0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (rmol .LT. 0) THEN
      ar = ((1.0D0-9.0D0*zr*rmol)**0.25D0+0.001D0)**2
      ao = ((1.0D0-9.0D0*z0*rmol)**0.25D0+0.001D0)**2
      polint = 0.74D0*(ALOG((ar-1.0D0)/(ar+1.0D0))-ALOG((ao-1.0D0)/(ao+1.0D0)))
      CALL PUSHCONTROL2B(2)
    ELSE IF (rmol .EQ. 0.) THEN
      polint = 0.74D0*ALOG(zr/z0)
      CALL PUSHCONTROL2B(1)
    ELSE
      polint = 0.74D0*ALOG(zr/z0) + 4.7D0*rmol*(zr-z0)
      CALL PUSHCONTROL2B(0)
    END IF
    IF (ustar .LT. 1.0d-4) THEN
      CALL PUSHCONTROL1B(0)
      max2 = 1.0d-4
    ELSE
      max2 = ustar
      CALL PUSHCONTROL1B(1)
    END IF
    temp4b0 = a_aer_res/(karman*max2)
    a_polint = temp4b0
    a_max2 = -(polint*temp4b0/max2)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) a_ustar = a_ustar + a_max2
    temp4b = vk*a_vgpart/polint
    a_ustar = a_ustar + temp4b
    a_polint = a_polint - ustar*temp4b/polint
    DO l=numgas,1,-1
      temp3 = 2.0D0*scpr23(l) + polint
      temp3b2 = vk*a_depv(l)/temp3
      a_ustar = a_ustar + temp3b2
      a_polint = a_polint - ustar*temp3b2/temp3
      a_depv(l) = 0.0_8
    END DO
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      temp3b0 = 0.74D0*a_polint/zr
      temp3b1 = 4.7D0*rmol*a_polint
      a_zr = temp3b1 + temp3b0
      a_z0 = a_z0 - temp3b1 - zr*temp3b0/z0
      a_rmol = a_rmol + 4.7D0*(zr-z0)*a_polint
    ELSE IF (branch .EQ. 1) THEN
      temp3b = 0.74D0*a_polint/zr
      a_zr = temp3b
      a_z0 = a_z0 - zr*temp3b/z0
    ELSE
      temp2 = (ao-1.0D0)/(ao+1.0D0)
      temp1 = (ar-1.0D0)/(ar+1.0D0)
      temp1b = 0.74D0*a_polint/(temp1*(ar+1.0D0))
      temp2b = -(0.74D0*a_polint/(temp2*(ao+1.0D0)))
      a_ar = (1.0D0-temp1)*temp1b
      a_ao = (1.0D0-temp2)*temp2b
      temp0 = -(9.0D0*z0*rmol) + 1.0D0
      temp0b = -(0.25D0*temp0**(-0.75D0)*2.D0*(temp0**0.25D0+0.001D0)*9.0D0*a_ao)
      a_z0 = a_z0 + rmol*temp0b
      temp = -(9.0D0*zr*rmol) + 1.0D0
      tempb = -(0.25D0*temp**(-0.75D0)*2.D0*(temp**0.25D0+0.001D0)*9.0D0*a_ar)
      a_rmol = a_rmol + zr*tempb + z0*temp0b
      a_zr = rmol*tempb
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(rmol)
      a_rmol = 0.0_8
    END IF
  END SUBROUTINE A_DEPVEL

END MODULE A_MODULE_DEP_SIMPLE
