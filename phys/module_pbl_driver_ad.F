!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of pbl_driver in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: v_phy rublten dusfcg z dvsfcg pblh 
!                pi_phy rqvblten dtauy3d rvblten qv_curr t_phy
!                rqcblten rthblten u_phy rqiblten dtaux3d p8w mut 
!                chem
!   with respect to varying inputs: v_phy rublten wspd ust pblh 
!                th_phy hfx dusfcg z dvsfcg pi_phy rqvblten dtauy3d 
!                rvblten qv_curr vd t_phy qfx rqcblten rthblten 
!                u_phy rqiblten dtaux3d qc_curr rho p8w mut chem
!                qi_curr dz8w
!   RW status of diff variables: v_phy:incr rublten:in-out wspd:out
!                ust:out pblh:in-out th_phy:out hfx:out dusfcg:in-out
!                z:incr dvsfcg:in-out pi_phy:incr rqvblten:in-out
!                dtauy3d:in-out rvblten:in-out qv_curr:incr vd:out t_phy:incr
!                rqcblten:in-out qfx:out rthblten:in-out u_phy:incr 
!                rqiblten:in-out qc_curr:out dtaux3d:in-out rho:out p8w:incr 
!                mut:incr chem:in-out qi_curr:out dz8w:out
!WRF:MEDIATION_LAYER:PHYSICS
!
MODULE A_MODULE_PBL_DRIVER
  IMPLICIT NONE

CONTAINS
!------------------------------------------------------------------
SUBROUTINE A_PBL_DRIVER(itimestep, dt, u_frame, v_frame, bldt, curr_secs&
&  , adapt_step_flag, bldtacttime, rublten, a_rublten, rvblten, a_rvblten, &
&  rthblten, a_rthblten, tsk, xland, znt, ht, ust, a_ust, pblh, a_pblh, &
&  hfx, a_hfx, qfx, a_qfx, grdflx&
&  , u_phy, a_u_phy, v_phy, a_v_phy, th_phy, a_th_phy, rho, a_rho, &
&  p_phy, pi_phy, a_pi_phy, &
&  p8w, a_p8w, t_phy, a_t_phy, dz8w, a_dz8w, z, a_z, exch_h, exch_m, akhs, akms, &
&  thz0, qz0, uz0, vz0, qsfc, f, lowlyr, u10, v10, t2, psim, psih, fm, &
&  fhh, gz1oz0, wspd, a_wspd, br, chklowq, bl_pbl_physics, ra_lw_physics, dx, &
&  stepbl, warm_rain, kpbl, mixht, ct, lh, snow, xice, znu, znw, mut, &
&  a_mut, p_top, ctopo, ctopo2, te_temf, km_temf, kh_temf, shf_temf, &
&  qf_temf, uw_temf, vw_temf, hd_temf, lcl_temf, hct_temf, wupd_temf, &
&  mf_temf, thup_temf, qtup_temf, qlup_temf, exch_temf, cf3d_temf, &
&  cfm_temf, flhc, flqc, qke, qke_adv, bl_mynn_tkeadvect, tsq, qsq, cov, &
&  rmol, ch, qcg, grav_settling, el_mynn, dqke, qwt, qshear, qbuoy, qdiss&
&  , bl_mynn_tkebudget, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme&
&  , kms, kme, i_start, i_end, j_start, j_end, kts, kte, num_tiles, hol, &
&  mol, regime, gwd_opt, dtaux3d, a_dtaux3d, dtauy3d, a_dtauy3d, dusfcg, &
&  a_dusfcg, dvsfcg, a_dvsfcg, var2d, oc12d, oa1, oa2, oa3, oa4, ol1, ol2, &
&  ol3, ol4, qv_curr, a_qv_curr, qc_curr, a_qc_curr, qr_curr, qi_curr, a_qi_curr, qs_curr, &
&  qg_curr, rqvblten, a_rqvblten, rqcblten, a_rqcblten, rqiblten, a_rqiblten&
&  , rqrblten, rqsblten, rqgblten, f_qv, f_qc, f_qr, f_qi, f_qs, f_qg, &
&  frc_urb2d, a_u_bep, a_v_bep, a_t_bep, a_q_bep, b_u_bep, b_v_bep, &
&  b_t_bep, b_q_bep, sf_bep, vl_bep, sf_sfclay_physics, sf_urban_physics&
&  , tke_pbl, el_pbl, wu_tur, wv_tur, wt_tur, wq_tur, exch_tke&
&  , a_e_bep, b_e_bep, dlg_bep, dl_u_bep, mfshconv, massflux_edkf, &
&  entr_edkf, detr_edkf, thl_up, thv_up, rt_up, rv_up, rc_up, u_up, v_up&
&  , frac_up, rc_mf, phb, xlat_u, xlong_u, xlat_v, xlong_v, id, z_at_w, &
&  cldfra_old_mp, cldfra, rthratenlw, tauresx2d, tauresy2d, tpert2d, &
&  qpert2d, wpert2d, wsedl3d, turbtype3d, smaw3d, fnm, fnp, qnc_curr, &
&  f_qnc, qni_curr, f_qni, rqniblten, wstar, delta &
#if (WRF_CHEM == 1)
&  ,chem, a_chem, vd, a_vd, nchem, kdvel, ndvel, num_vert_mix  &
#endif
&                                                               )

  USE module_state_description, ONLY :                            &
                   YSUSCHEME,MRFSCHEME,GFSSCHEME,MYJPBLSCHEME,ACMPBLSCHEME,&
                   QNSEPBLSCHEME,MYNNPBLSCHEME2,MYNNPBLSCHEME3,BOULACSCHEME,&
                   CAMUWPBLSCHEME,BEPSCHEME,BEP_BEMSCHEME,MYJSFCSCHEME, &
                   SURFDRAGSCHEME, TEMFPBLSCHEME, &
                   p_qi, param_first_scalar
!#if (WRF_CHEM == 1)
!                   num_chem, &
!#endif
                   

  USE module_model_constants


  USE MODULE_BL_GWDO
  USE MODULE_BL_SURFACE_DRAG
  USE MODULE_BL_ACM
  USE A_MODULE_BL_GWDO
  USE A_MODULE_BL_SURFACE_DRAG
  USE A_MODULE_BL_ACM
  IMPLICIT NONE

!======================================================================
! Grid structure in physics part of WRF
!----------------------------------------------------------------------
! The horizontal velocities used in the physics are unstaggered
! relative to temperature/moisture variables. All predicted
! variables are carried at half levels except w, which is at full
! levels. Some arrays with names (*8w) are at w (full) levels.
!
!----------------------------------------------------------------------
! In WRF, kms (smallest number) is the bottom level and kme (largest
! number) is the top level.  In your scheme, if 1 is at the top level,
! then you have to reverse the order in the k direction.
!
!         kme      -   half level (no data at this level)
!         kme    ----- full level
!         kme-1    -   half level
!         kme-1  ----- full level
!         .
!         .
!         .
!         kms+2    -   half level
!         kms+2  ----- full level
!         kms+1    -   half level
!         kms+1  ----- full level
!         kms      -   half level
!         kms    ----- full level
!
!======================================================================
! Definitions
!-----------
! Rho_d      dry density (kg/m^3)
! Theta_m    moist potential temperature (K)
! Qv         water vapor mixing ratio (kg/kg)
! Qc         cloud water mixing ratio (kg/kg)
! Qr         rain water mixing ratio (kg/kg)
! Qi         cloud ice mixing ratio (kg/kg)
! Qs         snow mixing ratio (kg/kg)
! QNC        cloud Liq number concentration (#/kg) !For CAMUWPBL scheme
! QNI        cloud ice number concentration (#/kg) !For CAMUWPBL scheme
!-----------------------------------------------------------------
!-- RUBLTEN       U tendency due to 
!                 PBL parameterization (m/s^2)
!-- RVBLTEN       V tendency due to 
!                 PBL parameterization (m/s^2)
!-- RTHBLTEN      Theta tendency due to 
!                 PBL parameterization (K/s)
!-- RQVBLTEN      Qv tendency due to 
!                 PBL parameterization (kg/kg/s)
!-- RQCBLTEN      Qc tendency due to 
!                 PBL parameterization (kg/kg/s)
!-- RQIBLTEN      Qi tendency due to 
!                 PBL parameterization (kg/kg/s)
!-- RQNIBLTEN     Qni tendency due to 
!                 PBL parameterization (#/kg/s) !For CAMUWPBL scheme
!-- id            WRF grid id  (optional, only needed by turbine drag schemes)
!-- itimestep     number of time steps
!-- GLW           downward long wave flux at ground surface (W/m^2)
!-- GSW           downward short wave flux at ground surface (W/m^2)
!-- EMISS         surface emissivity (between 0 and 1)
!-- TSK           surface temperature (K)
!-- TMN           soil temperature at lower boundary (K)
!-- XLAND         land mask (1 for land, 2 for water)
!-- ZNT           roughness length (m)
!-- MAVAIL        surface moisture availability (between 0 and 1)
!-- UST           u* in similarity theory (m/s)
!-- MOL           T* (similarity theory) (K)
!-- HOL           PBL height over Monin-Obukhov length
!-- PBLH          PBL height (m)
!-- CAPG          heat capacity for soil (J/K/m^3)
!-- THC           thermal inertia (Cal/cm/K/s^0.5)
!-- SNOWC         flag indicating snow coverage (1 for snow cover)
!-- HFX           upward heat flux at the surface (W/m^2)
!-- QFX           upward moisture flux at the surface (kg/m^2/s)
!-- REGIME        flag indicating PBL regime (stable, unstable, etc.)
!-- exch_m        exchange coefficient for momentum, m^2/s
!-- exch_h        exchange coefficient for heat, K m/s 
!-- exch_tke      exchange coeff. for TKE [enhanced], m^2/s (gbmpbl scheme)
!-- rthraten      tendency from radiation, used in GBM PBL scheme
!-- akhs          sfc exchange coefficient of heat/moisture from MYJ
!-- akms          sfc exchange coefficient of momentum from MYJ
!-- tke_pbl       turbulence kinetic energy from PBL schemes (m^2/s^2)
!-- el_pbl        length scale from PBL schemes (m)
!-- wu_tur        turbulent flux of momentum (x) (m^2/s^2)
!-- wv_tur        turbulent flux of momentum (y) (m^2/s^2)
!-- wt_tur        turbulent flux of potential temperature  (K m/s)
!-- wq_tur        turbulent flux of water vapor  (- m/s)
!-- te_temf       Total energy from TEMF BL scheme
!-- km_temf       Exchange coefficient for momentum from TEMF BL scheme
!-- kh_temf       Exchange coefficient for heat from TEMF BL scheme
!-- shf_temf      Sensible heat flux from TEMF BL scheme
!-- qf_temf       Water vapor flux from TEMF BL scheme
!-- uw_temf       Momentum flux in U direction from TEMF BL scheme
!-- vw_temf       Momentum flux in V direction from TEMF BL scheme
!-- wupd_temf     Updraft velocity from TEMF BL scheme
!-- mf_temf       Mass flux from TEMF BL scheme
!-- thup_temf     Updraft thetal from TEMF BL scheme
!-- qtup_temf     Updraft qt from TEMF BL scheme
!-- qlup_temf     Updraft ql from TEMF BL scheme
!-- cf3d_temf     3D cloud fraction from TEMF PBL
!-- cfm_temf      Column cloud fraction from TEMF PBL
!-- exch_temf     Surface exchange coefficient (as for moisture) from TEMF surface layer scheme
!-- flhc          Surface exchange coefficient for heat (for TEMF)
!-- flqc          Surface exchange coefficient for moisture (for TEMF)
!-- thz0          potential temperature at roughness length (K)
!-- uz0           u wind component at roughness length (m/s)
!-- vz0           v wind component at roughness length (m/s)
!-- qsfc          specific humidity at lower boundary (kg/kg)
!-- th2           diagnostic 2-m theta from surface layer and lsm
!-- t2            diagnostic 2-m temperature from surface layer and lsm
!-- q2            diagnostic 2-m mixing ratio from surface layer and lsm
!-- lowlyr        index of lowest model layer above ground
!-- rr            dry air density (kg/m^3)
!-- u_phy         u-velocity interpolated to theta points (m/s)
!-- v_phy         v-velocity interpolated to theta points (m/s)
!-- th_phy        potential temperature (K)
!-- p_phy         pressure (Pa)
!-- pi_phy        exner function (dimensionless)
!-- p8w           pressure at full levels (Pa)
!-- t_phy         temperature (K)
!-- dz8w          dz between full levels (m)
!-- z             height above sea level (m)
!-- DX            horizontal space interval (m)
!-- DT            time step (second)
!-- n_moist       number of moisture species
!-- PSFC          pressure at the surface (Pa)
!-- TSLB          
!-- ZS
!-- DZS
!-- num_soil_layers number of soil layer
!-- IFSNOW      ifsnow=1 for snow-cover effects
!-- z_at_w      Height above sea level at layer interfaces (m) 
!-- cldfra      Cloud fraction [unitless]
!-- cldfra_old_mp      Cloud fraction [unitless]
!-- rthratenlw  Tendency for LW ( K/s)
!-- tauresx2d   X-COMP OF RESIDUAL STRESS(m^2/s^2)
!-- tauresy2d   Y-COMP OF RESIDUAL STRESS(m^2/s^2)
!-- tpert2d     Convective temperature excess (K)
!-- qpert2d     Convective humidity excess (kg/kg)
!-- wpert2d     Turbulent velocity excess (m/s)
!-- wsedl3d     Sedimentation velocity of stratiform liquid cloud droplet (m/s)
!-- turbtype3d  Turbulent interface types [ no unit ]  
!-- smaw3d      Normalized Galperin instability function for momentum  ( 0<= <=4.964 and 1 at neutral ) [no units]
!
!-- P_QV          species index for water vapor
!-- P_QC          species index for cloud water
!-- P_QR          species index for rain water
!-- P_QI          species index for cloud ice
!-- P_QNC         species index for cloud liq number concentration !For CAMUWPBL scheme
!-- P_QNI         species index for cloud ice number concentration !For CAMUWPBL scheme
!-- P_QS          species index for snow
!-- P_QG          species index for graupel
!-- ids           start index for i in domain
!-- ide           end index for i in domain
!-- jds           start index for j in domain
!-- jde           end index for j in domain
!-- kds           start index for k in domain
!-- kde           end index for k in domain
!-- ims           start index for i in memory
!-- ime           end index for i in memory
!-- jms           start index for j in memory
!-- jme           end index for j in memory
!-- kms           start index for k in memory
!-- kme           end index for k in memory
!-- jts           start index for j in tile
!-- jte           end index for j in tile
!-- kts           start index for k in tile
!-- kte           end index for k in tile
!
!******************************************************************
!------------------------------------------------------------------ 
!
    INTEGER, INTENT(IN) :: bl_pbl_physics, ra_lw_physics, &
&    sf_sfclay_physics, sf_urban_physics
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, kts, kte, num_tiles
    INTEGER, DIMENSION(num_tiles), INTENT(IN) :: i_start, i_end, j_start&
&    , j_end
    INTEGER, INTENT(IN) :: itimestep, stepbl
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: lowlyr
!
    LOGICAL, INTENT(IN) :: warm_rain
    REAL, DIMENSION(kms:kme), OPTIONAL, INTENT(IN) :: znu, znw
!
    REAL, INTENT(IN) :: dt, dx
    REAL, INTENT(IN), OPTIONAL :: bldt
    REAL, INTENT(IN), OPTIONAL :: curr_secs
    LOGICAL, INTENT(IN), OPTIONAL :: adapt_step_flag
    REAL, INTENT(INOUT), OPTIONAL :: bldtacttime
! Optional for Wind Turbine Parameterizations
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN), OPTIONAL :: &
&    phb
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN), OPTIONAL :: xlat_u, &
&    xlong_u, xlat_v, xlong_v
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: p_phy, &
&    pi_phy, p8w, rho, t_phy, u_phy, v_phy, dz8w, z, th_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_pi_phy, a_p8w, &
&    a_rho, a_t_phy, a_u_phy, a_v_phy, a_dz8w, a_z, a_th_phy
!1D variables required for CAMUWPBL scheme
    REAL, DIMENSION(kms:kme), INTENT(IN), OPTIONAL :: fnm, fnp
!3D Variables for camuwpbl scheme
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN), OPTIONAL :: &
&    z_at_w, cldfra_old_mp, cldfra, rthratenlw, wsedl3d
!2D Variables required by camuwpbl scheme
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: &
&    tauresx2d, tauresy2d, tpert2d, qpert2d, wpert2d
!3D Variables for camuwpbl scheme - out
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(OUT), OPTIONAL :: &
&    turbtype3d, smaw3d
!
! for grims shallow convection with ysupbl
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: wstar
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: delta
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: xland, ht, psim, &
&    psih, fm, fhh, gz1oz0, br, f, chklowq
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tsk, ust, pblh, &
&    hfx, qfx, znt, qsfc, akhs, akms, mixht, qz0, thz0, uz0, vz0, ct, &
&    grdflx, u10, v10, t2, wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_ust
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rublten&
&    , rvblten, rthblten, exch_h, exch_m, tke_pbl
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rublten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(OUT) :: wu_tur, &
&    wv_tur, wt_tur, wq_tur
!
!MYNN
!,k_m,k_h,k_q &
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: tsq, qsq, cov, qke, el_mynn, dqke, qwt, qshear, qbuoy, qdiss
    INTEGER, OPTIONAL, INTENT(IN) :: bl_mynn_tkebudget, grav_settling
!ACF-QKE advection start
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&    qke_adv
    LOGICAL, OPTIONAL, INTENT(IN) :: bl_mynn_tkeadvect
!ACF-QKE advection end
! for GBM PBL scheme
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&    exch_tke
    INTEGER, OPTIONAL :: id
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: qcg, rmol&
&    , ch
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(OUT) :: el_pbl
    REAL, INTENT(IN) :: u_frame, v_frame
!
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: kpbl
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: xice, snow, lh
! Bep changes: variable added for urban
! URBAN Landuse fraction
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    frc_urb2d
! Implicit component for the momemtum in X-direction
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: a_u_bep
! Implicit component for the momemtum in Y-direction
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: a_v_bep
! Implicit component for the Pot. Temp.
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: a_t_bep
! Implicit component for Moisture
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: a_q_bep
! Implicit component for the TKE
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: a_e_bep
! Explicit component for the momemtum in X-direction
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: b_u_bep
! Explicit component for the momemtum in Y-direction
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: b_v_bep
! Explicit component for the Pot. Temp.
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: b_t_bep
! Explicit component for Moisture
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: b_q_bep
! Explicit component for the TKE
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: b_e_bep
! Height above ground (L_ground in formula (24) of the BLM paper). 
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: dlg_bep
! Length scale (lb in formula (22) ofthe BLM paper).
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: dl_u_bep
! urban surface and volumes        
! surfaces
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: sf_bep
! volumes
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: vl_bep
! Bep changes end
!  New variables for TEMF scheme
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: te_temf
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(OUT) ::&
&    km_temf, kh_temf, shf_temf, qf_temf, uw_temf, vw_temf, wupd_temf, &
&    mf_temf, thup_temf, qtup_temf, qlup_temf, cf3d_temf
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: flhc, &
&    flqc
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: hd_temf&
&    , lcl_temf, hct_temf, cfm_temf
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    exch_temf
!
!
! Optional
!
!
! Flags relating to the optional tendency arrays declared above
! Models that carry the optional tendencies will provdide the
! optional arguments at compile time; these flags all the model
! to determine at run-time whether a particular tracer is in
! use or not.
!
    LOGICAL, INTENT(IN), OPTIONAL :: f_qv, f_qc, f_qr, f_qi, f_qs, f_qg, &
&  f_qnc, f_qni
! optional moisture tracers
! 2 time levels; if only one then use CURR
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: qv_curr, qc_curr, qr_curr, qi_curr, qs_curr, qg_curr, qnc_curr, &
&    qni_curr, rqvblten, rqcblten, rqrblten, rqiblten, rqsblten, rqgblten, &
&    rqniblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL :: a_qv_curr, &
&    a_qc_curr, a_qi_curr, a_rqvblten, a_rqcblten, a_rqiblten
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: hol, &
&    mol, regime
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: mut
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL :: a_mut
!
    INTEGER, OPTIONAL, INTENT(IN) :: gwd_opt
    REAL, OPTIONAL, INTENT(IN) :: p_top
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: dtaux3d, dtauy3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL :: a_dtaux3d, &
&    a_dtauy3d
!
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: dusfcg&
&    , dvsfcg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL :: a_dusfcg, a_dvsfcg
!
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: var2d, &
&    oc12d, oa1, oa2, oa3, oa4, ol1, ol2, ol3, ol4
! paj
!mchen
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: ctopo, &
&    ctopo2
! Variables and Diagnostic for QNSE and EDKF JP
    INTEGER, INTENT(IN) :: mfshconv
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(OUT) ::&
&    massflux_edkf, entr_edkf, detr_edkf, thl_up, thv_up, rt_up, rv_up, &
&    rc_up, u_up, v_up, frac_up, rc_mf
#if (WRF_CHEM == 1)
!   ACM Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, nchem), INTENT(INOUT) :: &
&    chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, nchem), INTENT(INOUT) :: &
&    a_chem
    REAL, DIMENSION(ims:ime, kdvel, jms:jme, ndvel), INTENT(IN) :: vd
    REAL, DIMENSION(ims:ime, kdvel, jms:jme, ndvel) :: a_vd
#endif
!  LOCAL  VAR
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: v_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_v_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: u_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_u_phytmp
    REAL, DIMENSION(ims:ime, jms:jme) :: tskold, ustold, zntold, zol, &
&    psfc
! make these allocatable depending on the setting of idiff
! Typically, we try to avoide allocating and deallocating local storage like this
! so as not to fragment the stack. But at this point, the idiff = 1 case is disabled
! (set to 0 for all cases) and has to be set manually by users who want to work with
! it.  When it becomes a more standard option, this should be redone, either defining
! these as state with package clauses to turn them on and off and passing them in,
! or pass in an integer flag that can be used to dimension the arrays to 1:1:1 as
! local variables.  JM 20100316
! Implicit component for the momemtum in X-direction
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: a_u
! Implicit component for the momemtum in Y-direction
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: a_v
! Implicit component for the Pot. Temp.
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: a_t
! Implicit component for the water vapor
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: a_q
! Explicit component for the momemtum in X-direction
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: b_u
! Explicit component for the momemtum in Y-direction
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: b_v
! Explicit component for the Pot. Temp.
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: b_t
! Explicit component for the water vapor
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: b_q
! surfaces
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: sf
! volumes
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: vl
    REAL :: dtmin, dtbl
!
    INTEGER :: initflag
!
    INTEGER :: i, j, k, nk, jj, ij, its, ite, jts, jte
    LOGICAL :: radiation
    LOGICAL :: flag_bep
    LOGICAL :: flag_myjsfc
!flag_qnc,flag_qnc are used in camuwpbl scheme
    LOGICAL :: flag_qv, flag_qc, flag_qr, flag_qi, flag_qs, flag_qg, &
&    flag_qnc, flag_qni
    CHARACTER(len=256) :: message
    REAL :: next_bl_time
    LOGICAL :: run_param, doing_adapt_dt, decided
    LOGICAL :: do_adapt
    INTEGER :: iu_bep, iurb, idiff
    REAL :: seamask, thsk, zzz, unew, vnew, tnew, qnew, umom, vmom
    REAL :: z0, z1, z2, w1, w2
!------------------------------------------------------------------
!
    INTEGER :: branch
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_from
    INTEGER :: ad_to1
    INTEGER :: ad_from0
    INTEGER :: ad_to2
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_hfx
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rthblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rvblten
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_pblh
    INTEGER :: min2
    INTEGER :: min3
    flag_qi = .false.
    IF (PRESENT(f_qi)) flag_qi = f_qi

    IF (bl_pbl_physics .NE. 0) THEN
! RAINBL in mm (Accumulation between PBL calls)
!
      doing_adapt_dt = .false.
      IF (PRESENT(adapt_step_flag)) THEN
        IF (adapt_step_flag) THEN
          doing_adapt_dt = .true.
          IF (bldtacttime .EQ. 0.) bldtacttime = curr_secs + bldt*60.
        END IF
      END IF
!  Do we run through this scheme or not?
!    Test 1:  If this is the initial model time, then yes.
!                ITIMESTEP=1
!    Test 2:  If the user asked for the pbl to be run every time step, then yes.
!                BLDT=0 or STEPBL=1
!    Test 3:  If not adaptive dt, and this is on the requested pbl frequency, then yes.
!                MOD(ITIMESTEP,STEPBL)=0
!    Test 4:  If using adaptive dt and the current time is past the last requested activate pbl time, then yes.
!                CURR_SECS >= BLDTACTTIME
!  If we do run through the scheme, we set the flag run_param to TRUE and we set the decided flag
!  to TRUE.  The decided flag says that one of these tests was able to say "yes", run the scheme.
!  We only proceed to other tests if the previous tests all have left decided as FALSE.
!  If we set run_param to TRUE and this is adaptive time stepping, we set the time to the next
!  pbl run.
      run_param = .false.
      decided = .false.
      IF (.NOT.decided .AND. itimestep .EQ. 1) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (PRESENT(bldt)) THEN
        IF (.NOT.decided .AND. (bldt .EQ. 0. .OR. stepbl .EQ. 1)) THEN
          run_param = .true.
          decided = .true.
        END IF
      ELSE IF (.NOT.decided .AND. stepbl .EQ. 1) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (.NOT.decided .AND. (.NOT.doing_adapt_dt) .AND. MOD(itimestep, &
&          stepbl) .EQ. 0) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (.NOT.decided .AND. doing_adapt_dt .AND. curr_secs .GE. &
&          bldtacttime) THEN
        run_param = .true.
        decided = .true.
        bldtacttime = curr_secs + bldt*60.D0
      END IF
      IF (run_param) THEN
!---- 
! CALCULATE CONSTANT
! PBL schemes need PBL time step for updates
        IF (PRESENT(adapt_step_flag)) THEN
          IF (adapt_step_flag) THEN
            do_adapt = .true.
          ELSE
            do_adapt = .false.
          END IF
        ELSE
          do_adapt = .false.
        END IF
        IF (PRESENT(bldt)) THEN
          IF (bldt .EQ. 0.) THEN
            dtbl = dt
          ELSE IF (do_adapt) THEN
            dtbl = bldt*60.D0
          ELSE
            dtbl = dt*stepbl
          END IF
        ELSE
          dtbl = dt*stepbl
        END IF
! SAVE OLD VALUES
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij,i,j,k )
        DO ij=1,num_tiles
          ad_from0 = j_start(ij)
          DO j=ad_from0,j_end(ij)
            ad_from = i_start(ij)
            DO i=ad_from,i_end(ij)
! REVERSE ORDER IN THE VERTICAL DIRECTION
! testing change later
              DO k=kts,kte
                v_phytmp(i, k, j) = v_phy(i, k, j) + v_frame
                u_phytmp(i, k, j) = u_phy(i, k, j) + u_frame
              END DO
! PSFC : in Pa
         PSFC(I,J)=p8w(I,kms,J)
              IF (kte + 1 .GT. kde) THEN
                min3 = kde
              ELSE
                min3 = kte + 1
              END IF
              DO k=kts,min3
                rthblten(i, k, j) = 0.D0
                rublten(i, k, j) = 0.D0
                rvblten(i, k, j) = 0.D0
                IF (PRESENT(rqcblten)) THEN
                  rqcblten(i, k, j) = 0.D0
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (PRESENT(rqvblten)) THEN
                  rqvblten(i, k, j) = 0.D0
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              END DO
              CALL PUSHINTEGER4(k - 1)
              IF (flag_qi .AND. PRESENT(rqiblten)) THEN
                IF (kte + 1 .GT. kde) THEN
                  min2 = kde
                ELSE
                  min2 = kte + 1
                END IF
                DO k=kts,min2
                  rqiblten(i, k, j) = 0.D0
                END DO
                CALL PUSHINTEGER4(k - 1)
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
            CALL PUSHINTEGER4(i - 1)
            CALL PUSHINTEGER4(ad_from)
          END DO
          CALL PUSHINTEGER4(j - 1)
          CALL PUSHINTEGER4(ad_from0)
        END DO
!$OMP END PARALLEL DO
        a_u_phytmp = 0.0_8
        a_v_phytmp = 0.0_8





!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i,j,k, its, ite, jts, jte, z0, z1, z2, w1, w2, message, initflag )
        DO ij=1,num_tiles
          its = i_start(ij)
          ite = i_end(ij)
          jts = j_start(ij)
          jte = j_end(ij)
          SELECT CASE  (bl_pbl_physics) 
          CASE (acmpblscheme)
!!  These are values that are not supplied to pbl driver, but are required by ACM
            IF (PRESENT(qv_curr) .AND. PRESENT(qc_curr) .AND. PRESENT(&
&                rqvblten) .AND. PRESENT(rqcblten) .AND. .true.) THEN

               CALL PUSHREAL8ARRAY (pblh ,(ime-ims+1)*(jme-jms+1))
#if (WRF_CHEM == 1)
               CALL PUSHREAL8ARRAY (chem ,(ime-ims+1)*(kme-kms+1)*(jme-jms+1)*nchem)
#endif
               CALL ACMPBL(                                                        &
                 xtime=itimestep, dtpbl=dtbl, znw=znw, sigmah=znu               &
                ,u3d=u_phytmp, v3d=v_phytmp, pp3d=p_phy, dz8w=dz8w, th3d=th_phy, t3d=t_phy   &
                ,qv3d=qv_curr, qc3d=qc_curr, qi3d=qi_curr, rr3d=rho                &
#if (WRF_CHEM == 1)
                ,chem3d=chem,   vd3d=vd,  nchem=nchem, kdvel=kdvel              &
                ,ndvel=ndvel, num_vert_mix=num_vert_mix                         &
#endif
                ,ust=ust, hfx=hfx, qfx=qfx, tsk=tsk                               &
                ,psfc=psfc, ep1=ep_1, g=g, rovcp=rcp,rd=r_d,cpd=cp                 &
                ,pblh=pblh, kpbl2d=kpbl, exch_h=exch_h, regime=regime              &
                ,gz1oz0=gz1oz0,wspd=wspd,psim=psim, mut=mut                        &
                ,rublten=rublten,rvblten=rvblten,rthblten=rthblten                 &
                ,rqvblten=rqvblten,rqcblten=rqcblten,rqiblten=rqiblten             &
                ,ids=ids,ide=ide,jds=jds,jde=jde,kds=kds,kde=kde                   &
                ,ims=ims,ime=ime,jms=jms,jme=jme,kms=kms,kme=kme                   &
                ,its=its,ite=ite,jts=jts,jte=jte,kts=kts,kte=kte                   &   
                                                                            )
            END IF
          CASE (surfdragscheme) 
            CALL PUSHINTEGER4ARRAY(kpbl, (ime-ims+1)*(jme-jms+1))
            CALL SURFACE_DRAG(rublten=rublten, rvblten=rvblten, u_phy=&
&                        u_phy, v_phy=v_phy, z=z, xland=xland, ht=ht, &
&                        kpbl2d=kpbl, ids=ids, ide=ide, jds=jds, jde=jde, &
&                        kds=kds, kde=kde, ims=ims, ime=ime, jms=jms, jme=&
&                        jme, kms=kms, kme=kme, its=its, ite=ite, jts=jts, &
&                        jte=jte, kts=kts, kte=kte)
          CASE DEFAULT
          END SELECT
          IF (PRESENT(dtaux3d)) THEN
            IF (gwd_opt .EQ. 1) THEN
              CALL GWDO(u3d=u_phytmp, v3d=v_phytmp, t3d=t_phy, qv3d=&
&                  qv_curr, p3d=p_phy, p3di=p8w, pi3d=pi_phy, z=z, rublten=&
&                  rublten, rvblten=rvblten, dtaux3d=dtaux3d, dtauy3d=&
&                  dtauy3d, dusfcg=dusfcg, dvsfcg=dvsfcg, var2d=var2d, &
&                  oc12d=oc12d, oa2d1=oa1, oa2d2=oa2, oa2d3=oa3, oa2d4=oa4&
&                  , ol2d1=ol1, ol2d2=ol2, ol2d3=ol3, ol2d4=ol4, znu=znu, &
&                  znw=znw, p_top=p_top, cp=cp, g=g, rd=r_d, rv=&
&                  r_v, ep1=ep_1, pi=3.141592653, dt=dtbl, dx=dx, kpbl2d=&
&                  kpbl, itimestep=itimestep, ids=ids, ide=ide, jds=jds, &
&                  jde=jde, kds=kds, kde=kde, ims=ims, ime=ime, jms=jms, &
&                  jme=jme, kms=kms, kme=kme, its=its, ite=ite, jts=jts, &
&                  jte=jte, kts=kts, kte=kte)
            END IF
          END IF
        END DO
!$OMP END PARALLEL DO

!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i,j,k, its, ite, jts, jte, z0, z1, z2, w1, w2, message, initflag )
        DO ij=num_tiles,1,-1
          its = i_start(ij)
          ite = i_end(ij)
          jts = j_start(ij)
          jte = j_end(ij)
          IF (PRESENT(dtaux3d)) THEN
            IF (gwd_opt .EQ. 1) THEN
            CALL GWDO_B(u3d=u_phytmp, u3db=a_u_phytmp, v3d=v_phytmp, v3db&
&                  =a_v_phytmp, t3d=t_phy, t3db=a_t_phy, qv3d=qv_curr, &
&                  qv3db=a_qv_curr, p3d=p_phy, p3di=p8w, p3dib=a_p8w, pi3d=&
&                  pi_phy, pi3db=a_pi_phy, z=z, zb=a_z, rublten=rublten, &
&                  rubltenb=a_rublten, rvblten=rvblten, rvbltenb=a_rvblten&
&                  , dtaux3d=dtaux3d, dtaux3db=a_dtaux3d, dtauy3d=dtauy3d&
&                  , dtauy3db=a_dtauy3d, dusfcg=dusfcg, dusfcgb=a_dusfcg, &
&                  dvsfcg=dvsfcg, dvsfcgb=a_dvsfcg, var2d=var2d, oc12d=&
&                  oc12d, oa2d1=oa1, oa2d2=oa2, oa2d3=oa3, oa2d4=oa4, &
&                  ol2d1=ol1, ol2d2=ol2, ol2d3=ol3, ol2d4=ol4, znu=znu, &
&                  znw=znw, p_top=p_top, cp=cp, g=g, &
&                  rd=r_d, rv=r_v, ep1=ep_1, pi=3.141592653, dt=dtbl, dx=&
&                  dx, kpbl2d=kpbl, itimestep=itimestep, ids=ids, ide=ide&
&                  , jds=jds, jde=jde, kds=kds, kde=kde, ims=ims, ime=ime&
&                  , jms=jms, jme=jme, kms=kms, kme=kme, its=its, ite=ite&
&                  , jts=jts, jte=jte, kts=kts, kte=kte)
            END IF
          END IF
          SELECT CASE  (bl_pbl_physics) 
          CASE (acmpblscheme) 
!!  These are values that are not supplied to pbl driver, but are required by ACM
            IF (PRESENT(qv_curr) .AND. PRESENT(qc_curr) .AND. PRESENT(&
&                rqvblten) .AND. PRESENT(rqcblten) .AND. .true.) THEN
#if (WRF_CHEM == 1)
              CALL POPREAL8ARRAY (chem ,(ime-ims+1)*(kme-kms+1)*(jme-jms+1)*nchem)
#endif
              CALL POPREAL8ARRAY (pblh ,(ime-ims+1)*(jme-jms+1))
              CALL A_ACMPBL(xtime=itimestep, dtpbl=dtbl, znw=znw, sigmah&
&                      =znu, u3d=u_phytmp, a_u3d=a_u_phytmp, v3d=v_phytmp&
&                      , a_v3d=a_v_phytmp, pp3d=p_phy, dz8w=dz8w, a_dz8w=&
&                      a_dz8w, th3d=th_phy, a_th3d=a_th_phy, t3d=t_phy, &
&                      a_t3d=a_t_phy, qv3d=qv_curr, a_qv3d=a_qv_curr, &
&                      qc3d=qc_curr, a_qc3d=a_qc_curr, qi3d=qi_curr, &
&                      a_qi3d=a_qi_curr, rr3d=rho, a_rr3d=a_rho, &
#if (WRF_CHEM == 1)
                       chem3d=chem, a_chem3d=a_chem, vd3d=vd, a_vd3d=a_vd, &
                       nchem=nchem, kdvel=kdvel, ndvel=ndvel, num_vert_mix=&
                       num_vert_mix, &
#endif
                       ust=ust, a_ust=a_ust, hfx=hfx, a_hfx&
&                      =a_hfx, qfx=qfx, a_qfx=a_qfx, tsk=tsk, psfc=psfc, &
&                      ep1=ep_1, g=g, rovcp=rcp, rd=r_d, cpd=cp, pblh=&
&                      pblh, a_pblh=a_pblh, kpbl2d=kpbl, exch_h=exch_h, &
&                      regime=regime, gz1oz0=gz1oz0, wspd=wspd, a_wspd=&
&                      a_wspd, psim=psim, mut=mut, a_mut=a_mut, rublten=rublten, &
&                      a_rublten=a_rublten, rvblten=rvblten, a_rvblten=&
&                      a_rvblten, rthblten=rthblten, a_rthblten=&
&                      a_rthblten, rqvblten=rqvblten, a_rqvblten=&
&                      a_rqvblten, rqcblten=rqcblten, a_rqcblten=&
&                      a_rqcblten, rqiblten=rqiblten, a_rqiblten=&
&                      a_rqiblten, ids=ids, ide=ide, jds=jds, jde=jde, &
&                      kds=kds, kde=kde, ims=ims, ime=ime, jms=jms, jme=&
&                      jme, kms=kms, kme=kme, its=its, ite=ite, jts=jts, &
&                      jte=jte, kts=kts, kte=kte)

            END IF
          CASE (surfdragscheme)
            CALL POPINTEGER4ARRAY(kpbl, (ime-ims+1)*(jme-jms+1))
            CALL SURFACE_DRAG_B(rublten=rublten, rubltenb=a_rublten, &
&                          rvblten=rvblten, rvbltenb=a_rvblten, u_phy=u_phy&
&                          , u_phyb=a_u_phy, v_phy=v_phy, v_phyb=a_v_phy, &
&                          xland=xland, z=z, zb=a_z, ht=ht, kpbl2d=kpbl,  &
&                          ids=ids, ide=ide, jds=jds, jde=jde, kds=kds,   &
&                          kde=kde, ims=ims, ime=ime, jms=jms, jme=jme,   &
&                          kms=kms, kme=kme, its=its, ite=ite, jts=jts,   &
&                          jte=jte, kts=kts, kte=kte)
          CASE DEFAULT
          END SELECT
        END DO
!$OMP END PARALLEL DO

!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij,i,j,k )
        DO ij=num_tiles,1,-1
          CALL POPINTEGER4(ad_from0)
          CALL POPINTEGER4(ad_to2)
          DO j=ad_to2,ad_from0,-1
            CALL POPINTEGER4(ad_from)
            CALL POPINTEGER4(ad_to1)
            DO i=ad_to1,ad_from,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                CALL POPINTEGER4(ad_to0)
                DO k=ad_to0,kts,-1
                  a_rqiblten(i, k, j) = 0.0_8
                END DO
              END IF
              CALL POPINTEGER4(ad_to)
              DO k=ad_to,kts,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) a_rqvblten(i, k, j) = 0.0_8
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) a_rqcblten(i, k, j) = 0.0_8
                a_rvblten(i, k, j) = 0.0_8
                a_rublten(i, k, j) = 0.0_8
                a_rthblten(i, k, j) = 0.0_8
              END DO
              DO k=kte,kts,-1
                a_u_phy(i, k, j) = a_u_phy(i, k, j) + a_u_phytmp(i, k, j&
&                  )
                a_u_phytmp(i, k, j) = 0.0_8
                a_v_phy(i, k, j) = a_v_phy(i, k, j) + a_v_phytmp(i, k, j&
&                  )
                a_v_phytmp(i, k, j) = 0.0_8
              END DO
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
    END IF
  END SUBROUTINE A_PBL_DRIVER

END MODULE A_MODULE_PBL_DRIVER
